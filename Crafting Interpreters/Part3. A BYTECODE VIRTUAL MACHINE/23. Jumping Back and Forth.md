# Jumping Back and Forth 요약
if else, 논리연산자, while for 의 제어흐름문을 구현한다.
jlox 에서는 실행하는 코드조각이 AST 내 노드와 실행중인 자바코드에 의해서 암시적으로 결정되었지만 clox 는 ip 라는 명시적인 표현을 가지고 있다.
clox ip 를 조작하는 방식으로 제어흐름을 구현한다.
사용자의 코드를 컴파일 할때, JUMP 계열의 OP_CODE 를 에밋하고, 문장의 나머지 부분까지 컴파일 해서 점프할 위치를 알아낸뒤 chunk 에서 해당 OP_CODE 의 피연산자 부분에 올바른 값을 설정한다.
이를 백패칭 이라고 한다. 
각 제어흐름 문장을 컴파일 할 때 평가한 조건식을 스택에서 제거하는 OP_POP 을 실행해야 한다.


# 문단별 흥미로운 내용
- 제어 흐름에서 흐름은 실행이 프로그램의 텍스트를 이동하는 방식을 의미한다.
- JLox 코드 실행은 AST 노드와 실행중인 자바코드에 의해서 암시적으로 결정되었지만, CLox 에서는 이 개념이 훨씬 더 명시적이다. 
  VM의 ip 필드는 현재 바이트코드 명령어주소를 저장하고, 이 필드의 값은 프로그램 내에서 정확히 '우리가 위치한 곳'을 나타낸다. ip 를 조작하는 것으로 제어흐름을 만들 수 있다.
## 23.1 If statements
- script 는 전체가 다 컴파일 된 후에 vm 이 실행된다. repl 은 라인별로 컴파일된 후에 vm 이 실행된다.
- emitJump 로 OP_JUMP_IF_FALSE 와 임시 피연산자를 emit 한 다음, if 문장에 포함된 문장을 컴파일이 완료된 후에, patchJump 에서 문장의 범위만큼 건너 뛸수 있도록 피연산자를 덮어 씌운다.
### 23.1.1 Else clauses
- 각 문장은 stack effect 가 0 이어야 한다. 문장 실행후의 stack 상태는 이전의 stack 상태와 같아야 한다. 따라서 OP_POP 을 emit 하는것으로 계산된 조건식을 스택에서 꺼내야 한다.  
## 23.2 Logical Operators
- and_ 
### 23.2.1 Logical or operator
- or_: 
  - true  || true  -> true : 좌측 피연산자 값 true 를 stack 에 남기고 다음 문장으로 점프한다. 
  - true  || false -> true : 좌측 피연산자 값 true 를 stack 에 남기고 다음 문장으로 점프한다.
  - false || true  -> true : 좌측 피연산자 값이 false 면, 좌측 피연산자 값을 pop 하고 우측 피연산자 값을 stack 에 남기고 다음 문장으로 점프한다.  
  - false || false -> false: 좌측 피연산자 값이 false 면, 좌측 피연산자 값을 pop 하고 우측 피연산자 값을 stack 에 남기고 다음 문장으로 점프한다.
## 23.3 While Statements
## 23.4 For Statements
- for 문은 문장내에서 변수를 선언 할 수 있음으로 컴파일시에 scope() 를 호출해야 한다.

## Challenges
1. switch 문장을 지원하라.
2. continue 문장을 지원하라.
3. 조금더 선언적인 흐름제어 기능을 추가하라. 
 - 조금더 명령적, for (int i = 0; i < items.Count; i++)  { ...
 - 조금더 선언적, for (var item in items) { ...

## Design Note:Considering Goto Harmful
- Lox 의 구조화된 제어흐름은 원시적인 비구조적 점프로 컴파일된다.
- 다익스트라의 주장1
  - As programmers, we write programs—static text—but what we care about is the actual running program—its dynamic behavior.
  - We’re better at reasoning about static things than dynamic things.
  - Thus, the more we can make the dynamic execution of the program reflect its textual structure, the better.
- 다익스트라의 주장2 
  - 두 컴퓨터에서 어떤 프로그램을 정확히 같은 위치에서 정지시키기 위해서 필요한 데이터를 생각해보자, 어렵기는 하지만 콜스택과 구조화된 반복문의 반복횟수를 알고 있으면 정확히 같은 위치에서 정지시킬 수 있을것이다. goto 를 쓰는 순간 그것이 불가능해진다.
- 저자는 주장2 을 반박한다. 필요하다면 goto 에도 반복 횟수를 추척할 수 있고, 두 컴퓨터의 프로그램을 정확히 같은 위치에서 정지시킬 수 있다. 하지만 반복횟수는 동작을 추적하는데 그렇게 유의미하지 않다. 
  goto 문을 가지는 프로그램은 구조화된 제어흐름을 가지는 프로그램으로 바꿀 수 있다는게 증명되었다. 
- 저자는 말한다. 자신의 논리도 빈약하다. 수학을 가지고 하는 논리로는 그렇게 주장할 수 있지만, 이 문제는 경험적이고 인간중심적으로 접근해야 한다.
- 저자는 말한다. goto를 사용하는 일부코드는 정말로 나쁨으로 언어에서 goto 를 제어하고 구조화된 제어흐름을 사용하도록 하는게 순이득이 될수 있다.
  하지만 goto 를 사용했을때 훨씬 더 이해하기 쉬운 코드들이 있다. 설계결정을 할때 무조건적으로 배제하지 않고 장점과 단점을 세말하게 이해해야 한다. 특정 신조를 가지는 것은 창의적인 작업의 좋은 출발점이 될 수 없다. 
```c
for (int x = 0; x < xSize; x++) {
  for (int y = 0; y < ySize; y++) {
    for (int z = 0; z < zSize; z++) {
      if (matrix[x][y][z] == 0) {
        printf("found");
        goto done;
      }
    }
  }
}
done:
```