# Methods and Initializers 요약
메서드와 초기자 기능을 추가한다. 먼저 메서드의 선언 기능을 구현한다.
클래스의 리프레젠테이션에 메서드 필드를 추가한다. 이는 이름으로 엑세스 가능한 테이블 타입이다.  
클래스 선언을 컴파일 할때 메서드를 선언하는 코드를 발견하면 function() 으로 메서드 자체를 함수로 컴파일한다. 이는 OP_CLOSURE 를 에밋한다.
이어서 OP_METHOD 를 에밋한다.
OP_METHOD를 인터프리팅 할때, OP_CLOSURE 에 의해서 스택에 올라와 있는 함수 본체를 클래스이 메서드 필드에 설정한다.

메서드 참조 기능을 구현한다.
메서드에서는 this 키워드를 통해서 리시버를 참조할 수 있어야 한다. 이를 위해서 메서드의 런타임 표현인 ObjBoundMethod 구현한다.
이 리프레젠테이션은 ObjClosure 메서드 본체와 리시버를 래핑한다.
OP_GET_PROPERTY 을 해석할 때, 필드를 먼저 찾아보도록 하고, 이어서 메서드를 찾는다. 메서드를 찾으면 ObjBoundMethod 를 초기화 해서 스택에 올린다.
메서드는 OP_CALL 을 해석하며서 실행된다.

this 를 컴파일 할때는 this 지역변수 처럼 다룬다.
컴파일러가 초기화 될때 TYPE_METHOD 이면 (TYPE_FUNCTION 이 아니면) this 를 지역변수로 설정한다.
this 키워드가 컴파일 될 때, OP_GET_LOCAL 을 에밋한다. 
메서드 호출을 인터프리팅 할때, 콜 프래임의 0 번째 슬롯에 receiver 를 설정한다. 
이렇게 함으로써 this 에대한 OP_GET_LOCAL 인터프리팅이 올바르게 이루어질 수 있다.
currentClass 를 컴파일러에 설정하는 것으로 클래스 정의의 외부에서는 this 키워드가 컴파일 되지 않도록 한다.

초기자 기능을 구현한다. 먼저 초기자의 인터프리팅을 구현한다. 클래스를 callValue 로 호출 하면서 인스턴스를 생성할 때, init() 을 실행한다.
컴파일은 기존 메서드의 컴파일을 이용한다. 메서드 이름이 init 인 경우 초기자로 보고 TYPE_INITIALIZER 타입을 설정한다.
function() 으로 초기자 자체를 함수로 컴파일한다. 이는 OP_CLOSURE 를 에밋한다. 초기자에서 조기 리턴이 발생할 경우 this 를 가르키도록 OP_GET_LOCAL 을 에밋한다.

록스에서 메서드는 일급 값으로 변수에 할당 할 수 있다. 기존 프러퍼티 엑세스와 실행 시멘틱으로 메서드를 실행 할 수 있지만,
매번 할당과 실행이라는 오버헤드가 발생한다. 메서드는 어딘가에 할당되기 보다는 바로 실행되는 경우가 대부분임으로 이는 비효율 적이다.
이를 최적하 하기 위해서 매서드 발동(실행)을 최적화 한다.
dot 중위식을 컴파일 할때 괄호호 호출이 있다면, 바로 전용 옵코드 인 OP_INVOKE 를 에밋한다.
OP_INVOKE 를 인터프리팅 할 때 메서드를 constants 에서 읽어온 후 call 로 바로 실행한다.


# 문단별 흥미로운 내용

## 28.1 Method Declarations
### 28.1.1 Representing methods
- JLox 와 Clox 모두 클래스의 표현에 메서드가 포함된다. JLox 에서 메서드 필드는 파싱의 결과 AST 형태로 존재하고 런타임에 바로 이것을 사용했지만, CLox 에서는 메서드 필드는 바이트코드 시퀸스로 러타임에 전달되어야 한다.    
### 28.1.2 Compiling method declarations
- OP_CLASS 가 에밋된 상태에서 vm 은 ObjClass 를 이미 생성하고 있다. 이상태에서 컴파일러는 OP_METHOD 를 에밋한다.
![method-instructions](method-instructions.png)
### 28.1.3 Executing method declarations

## 28.2 Method References
### 28.2.1 Bound methods
- 록스에서 지역변수와 평가중의 임시값들을 스택에 있고, 전역 변수는 해시테이블, 변수와 클로저는 upvalues 에 저장된다. method 리시버를 추적하기 위해서는 새로운 런타임 타입이 필요하고 그것이 ObjBoundMethod 이다.
### 28.2.2 Accessing methods
![bind-method.png](bind-method.png)
### 28.2.3 Calling methods
- We can declare, access, and invoke methods.

## 28.3 This
- this 를 변수 이름인 것 처럼 처리한다. 그렇다면 this 가 로컬 변수처럼 선언되어야 하는데 이는 initCompiler 에서 수행한다.
  - 런타임에 메서드가 호출되는 시점에서 slot 0 의 this 가 receiver 를 가르키도록 stack 을 조작한다.
### 28.3.1 Misusing this

## 28.4 Instance Initializer
- OOP 언어에서 행동과 상태를 같이 묶는 이유는 객체가 항상 올바르고 의미있는 상태로 있는것을 보장하기 위함이다.
- 초기자는 다음처럼 동작해야 한다.
  - 런타임에서 클래스의 인스턴스가 만들어질때 마다 초기자가 실행되어야 한다.
  - 초기자가 실행된 결과로 호출자는 항상 인스턴스를 돌려받아야 한다. 초기자 내에서 무엇을 리턴하든 상관없, 명시적으로 this 를 리턴할 필요도 없다.
  - 초기자는 사실 어떤 값이든 리턴하는것이 금지되어 있다.
### 28.4.1 Invoking Initializer
- 클래스의 호출을 인터프리팅 할때 init 이라는 method 를 invoke 한다.
### 28.4.2 Initializer return values
- 자동으로 생성된 객체가 리턴되도록 해야한다.
### 28.4.3 Incorrect returns in initializer

## 28.5 Optimized Invocations
- method 는 엑세스한 뒤 호출되는 경우보다 바로 호출되는 경우가 압도적으로 많다. 그러나 엑세스 한 뒤 호출을 하기 위해서는 오버헤드가 발생한다.
  컴파일 타임에 메서드를 바로 실행하는걸 알 수 있다. 이를 이용해서 OP_GET_PROPERTY 와 OP_CALL 을 결합한 OP_INVOKE 를 에밋하고 이를 인터프리팅 하는것으로 최적화를 달성할 수 있다. 
### 28.5.1 Invoking fields

## Challenges
- 1. hashtable 에서 init() 메서드를 상수시간에 찾을 수 있지만 그래도 느리다. 더 빠른 것을 구현하라.
  - 해답: methods 필드가 아닌 initializer 필드를 ObjClass 에 추가한다.
- 2. Lox 와 같은 동적 타입 언어는, 하나의 호출지가 여러 클래스의 메서드를 호출 할 수 있다. (foo.bar() 에서 foo 에 어떤 클래스는 할당이 될 수 있다.)
   그렇다 하더라고 대부분의 경우는 항상 같은 클래스의 같은 메서드를 호출한다. 언어적으로 다형성을 지원하는 경우도 마찬가지로 대부분의 호출은 다형적이지 않다.
   언어 구현체가 이러한 관찰을 근거로 어떻게 최적화를 할까?
  - 해답: inline caching 을 사용한다. 첫번재 호출에서 클래스와 메서드를 저장해두고 두번째 호출에서 클래스이름이 같다면 바로 캐싱해둔 메서드를 호출하는걸로 다시 메서드를 조회하는 오버헤드를 감소시킬 수 있다.
- 3. OP_INVOKE 가 실행될때 필드를 조회한다음 메서드를 조회한다. 필드에 함수를 할당하는 경우는 거의 없지만 언어에서 같은 구문으로 필드와 메서드에 엑세스할 수 있다고 말하고 있음으로 구현해야 한다.
   이것은 성능에 영향을 미치는 언어 선택이다. 이것이 맞는 선택일까?
   - 해답: 메서드 접근고 필드 접근을 다른 문법으로 분리하면 이러한 문제를 해결할 수 있다. 




