# Garbage Collection 요약

가비지 컬랙터는 더이상 사용하지 않는 메모리를 회수하는 컴퍼넌트다.
이를 위히서는 메모리에 어떤 부분이 사용되 않는지 알아야 한다. 유저 프로그램이 어떤 방식으로든 참조 할 수 있는 값을 reachable 이라고 하고,
unreachable 한 값들이 저장되어 있는 메모리를 회수해야 한다. 이를 Reachability 라고 한다.
Mark sweep Garbage Collection 알고리즘을 사용한다. 이는 root 부터 시작해서 도달 가능한것들에 순회를 하면서 마킹을 하고, 
마킹이 없는 것들을 해제 하는 알고리즘이다. 
힙에 저장하고 있는 데이터 조각들중 reachable 한 것들에 점진적으로 마킹을 해나가고 도달할 수 없는 것들은 삭제한다.
GC 를 위한 순회는 그래프 순회 (DFS) 로 tricolor abstraction 에 비유 할 수 있다.
언제 가비지 컬랙션을 실행할지 결정해야 한다. 힙 공간이 재 설정 될 때 GC 가 실행되도록 한다.
GC 의 효율성을 측정하는 메트릭으로 throughput 과 latency 가 있다. 이는 트레이드 오프 관계이다.  
- throughput: GC 작업을 하는데 사용하는 시간조각 대비 유저 코드를 동작 시키는데 사용하는 시간조각. ex) throughput 90% 면, user 프로그램에 90% 의 시간을 쓰고 10% 는 GC 간접비가 된다.
- latency: GC 작업 때문에 유저의 프로그램이 멈추는 가장 긴 연속적인 시간.
Clox 의 vm 은 throughput 과 latency 의 트레이오프 조정에 자동 조정(self-adjusting)을 사용한다.
직전 힙의 사용량이 다음 GC 실행의 threshold 를 결정하게 한다.
GC 의 디버깅은 제대로 동작하지 않는 코드를 찾는게 아니라, 문제를 막는 코드의 부재를 찾는것 이기 때문에 디버깅이 어렵다. 
컴파일링 과정에서 등장하는 힙에 올라가는 객체들도 gc 에 의해서 관리되도록 vm에 stack 임시적으로 올리는 방식으로 처리해야한다.

# 문단별 흥미로운 내용
- We say Lox is a “high-level” language because it frees programmers from worrying about details irrelevant to the problem they’re solving.
- This is why Lox is a managed language, which means that the language implementation manages memory allocation and freeing on the user’s behalf.
- garbage collector: 더이상 사용하지 않는 메모리를 회수하는 컴퍼넌트

## 26.1 Reachability
- VM 은 나중에 읽을 수도 있는 메모리는 회수하지 않는 보수적인 접근을 한다. 그렇다고 모든 메모리 조각을 그렇게 바라보지는 않는다. 
  유저 프로그램이 어떤 방식으로든 참조 할 수 있는 값을 `reachable` 하다고 하는데 반대인 unreachable 한 값이 저장되어 있는 메모리만 회수한다.
- VM 이 다른 객체를 통해서 도달하지 않고 직접 도달할 수 있는 개체를 `root` 이라고 한다. root 말로 root 을 통해서 간접 참조되는 객체들도 reachable 하다. (클로저) 따라서 다음과 같이 정의를 reachable 의 정의를 말 할 수 있다.
  - 모든 `root` 은 `reachable` 하다.
  - `reachable` 한 오브젝트 에서 잠조되는 모든 오브젝트 또한 `reachable` 하다.  
- 위의 정의에 따라서 회수할 메모리에 대해 다음과 같은 알고리즘을 생각해 낼 수 있다.
  - 모든 `reachable` 한 오브젝트의 셋을 찾기 위해서 `root` 부터 시작해서 모든 참조를 순회한다.
  - 셋에 속하지 않는 오브젝트를 해제한다.

## 26.2 Mark-Sweep Garbage Collection
- mark-sweep GC 알고리즘
  - marking: root 부터 시작해서 그것이 참조하는 모든 오브젝트를 참조해서 마크한다.
  - sweep: 마킹 되지 않은 오브젝트는 unreachable 함으로 해제한다.

## 26.3 Marking the Roots
- 스택과, 전역변수를 저장하는 테이블의 모든 오브젝트를 순회하며 마킹한다.
### 26.3.1 Less obvious roots 
- CallFrames 은 클로저 오브젝트를 가지고 있음으로 이것들도 순회하며 마킹해야 한다. vm 이 관리하는 openUpvalues 들도 마킹해야한다.
- compiler 가 만드는 오브젝토도 마킹해야 한다. `memory.markRoots() → compiler.markCompilerRoots() → memory.markObject()`

## 26.4 Tracing Object References
- root 을 전부 마킹했음으로 이제는 간접적으로 도달 가능한 값들을 찾아서 마킹해야한다. ObjClosure 는 ObjUpvalue 의 리스트와 자신이 감싸는 ObjFunction 을 참조한다. 
  ObjFunction 은 다시 함수 바디에서 생성되는 리터럴들의 상수 테이블을 가지고있다. 이것들을 전부 찾아서 마킹해야한다.
### 26.4.1 The tricolor abstraction
- tricolor abstraction: GC 에서 오브젝트들을 순회하면서 마킹하는 것을 은유적으로 표현한 것 
  - white: GC 의 시작점의 모든 오브젝트의 상태로 아직 순회가 도달하지 않았음을 의미
  - gray: 마킹중, 방문했지만 완전히 처리되지 않은 상태로 이것이 다른 오브젝트를 참조하는지 확인하지 않은 상태
  - black: 마킹완료, 이것이 참조하는 다른 모든 오브젝트를 마킹중(gray) 으로 표시한 상태.
- 마킹 프로세스는 다음과 같다.
  - 1. 모든 객체를 white 로 표시, 
  - 2. 모든 root 을 찾아서 gray 로 표시
  - 3. 아래 과정을 gray 객체가 남아있는동안 계쏙 수행
    - 1. gray 객체를 하나 선택한다. gray 객체가 참조하는 모든 white 객체를 gray 로 바꾼다.
    - 2. 오리지널 gray 객체를 black 으로 바꾼다.
  ![tricolor-trace](tricolor-trace.png)
  ※ 인접한 노드를 전부 gray 로 칠한다고 BFS 가 아니다. 어떤 순서로 탐색이 완료되는지 (black)를 보면 DFS 다.   
- 프로세스가 완료되면 black 오브젝트가 white 를 참조하지 않는다. 이를 tricolor invariant 라고 한다. 
### 26.4.2 A worklist for gray objects
### 26.4.3 Processing gray objects
- 이미 마크된 object grayStack 에 추가하지 않아야 한다. it keeps the wavefront moving forward through only the white objects.
```
traceReference() 는 graph traversl 을 한다. 
실행시 grayStack 이 비워질때까지 순회를 한다.
순회 과정중에 재귀적으로 grayStack이 다시 채워진다. 
스택을 사용해서 깊이 우선 탐색을 한다.

traceReference()
  while empty
  Obj* object = vm.grayStack[--vm.grayCount];
  blackenObject(object);
    ↓  
blackenObject(obj)    
    ↓  
markObject(obj)
  vm.grayStack[vm.grayCapacity++] = object;
```

## 26.5 Sweeping Unused Objects
### 26.6.1 Weak references and the string pool
- intern　된 strings 들을 관라하고 있는 table 또한 도달하지 못하는 string 에 대한 포인터를 해제해 줘야 한다. 따라서 mark 작업이 끝난 후에 포인터가 가르키는 오브젝트가 마킹 되어있지 않으면 메모리에서 해제한다. 

## 26.6 When to Collect
### 26.6.1 Latency and throughput
- throughput: GC 작업을 하는데 사용하는 시간조각 대비 유저 코드를 동작 시키는데 사용하는 시간조각. ex) throughput 90% 면, user 프로그램에 90% 의 시간을 쓰고 10% 는 GC 간접비가 된다.
- latency: GC 작업 때문에 유저의 프로그램이 멈추는 가장 긴 연속적인 시간.
throughput 과 latency 간의 트레이드 오프를 해야한다. latency 를 우선해서 자주 GC 를 실행하면, 전체 오브젝트를 탐색하는데 시간을 사용하게 되어 throughput 이 낮아진다.
throughput 을 우선하면 탐색 과 GC 작접 자체의 효율을 올라가지만 latency 가 길어진다. 이는 유저에게 계속해서 입력을 받는 프로그램에는 치명적이다.
### 26.6.2 Self-adjusting heap
- The idea is that the collector frequency automatically adjusts based on the live size of the heap.
- reallocate 안에서 threshold 를 넘으면 GC 가 실행된다. 재귀적으로 reallocate 가 실행 되는데, 이때 vm.bytesAllocated 이 조정되고 GC 가 끝날때 다음 threshold 가 정해진다. 

## 26.7 Garbage Collection Bugs
- You’re looking for the absence of code which fails to prevent a problem, and that’s a much harder search.
### 26.7.1 Adding to the constant table
- (Value 는 vm.objects 에 등록되면서 생성된다.) addConstant 로 Value 를 constant 에 추가할때 Value 는 매개변수에만 붙어있다. 
  이때 GC가 일어나면 도달 불가능 하다고 판단되어서 sweep 됨으로, 도달가능 상태로 만들기 위해서 addConstant 에서 vm 에 stack 에 Value 를 잠시 올려놓아야 한다.        
### 26.7.2 Interning strings
### 26.7.3 Concatenating strings

## Challenge
- 1. Obj 헤더는 type, isMarked, next 세가지의 필드를 가지고 있다. 이것들은 얼마나 메모리를 차지하는가? 더 컴팩트하게 줄일수 있을까?
  - enum 1바이트, bool 1 바이트, 포인터 8 바이트 더 줄이기 힘들 것 같다.
- 2. 스윕 단계에서 다음 사이클을 준비하기 위해서 isMarked 를 클리어 한다. 이보다 더 효율적인 접근법을 생각할 수 있는가?
  - 꼭 필요한 순회를 하고 이 순회에 한번에 처리함으로 더 효율적인 접근방법은 없어 보인다.
- 3. 마스 스윕 가비지 컬랙션 알고리즘은 여러 가비지 컬랙션 알고리즘 중 하나다. 다른 알고리즘을 탐색하고 비교해 봐라. 
  - 참조 카운팅: 카운팅이 0 이 되면 바로 해제
  - 체니 알고리즘: 살아 있는 것들만 복사하기, 스택 없이 구현, 메모리 조각화 없음
  - Lisp 2 mark-compact algorithm: 기본적으로 마크스윕이지만, 살아있는 객체를 메모리에 차례로 할당해서 조각화를 줄임 
  - JVM의 선택: 마크 컴팩트 + 오브젝트 세대별 관리 

## Design Note: Generational collectors
오래 사는 객체는 계속 오래산다는 사실을 발견했다. 이 발견을 활용하는 알고리즘을 generational garbage collection 이라고 한다.
객체가 생성되면 비교적 빈번하게 GC가 실행되는 "작은" 힙의 영역에 둔다. 만약 GC 에서 객체가 살아 남으면 "큰" 힙 영역에 이동 시키고 덜 빈번하게 GC 가 실행된다.
(살아있는 객체를 순회하는데 시간이 소비된다는 사실에 기반한다. - 순회범위가 작아진다.)
이는 객체의 수명이 균등하게 분포되어 있지 않다는 실증적인 데이터에서 이점을 취하는 알고리즘 이다.
