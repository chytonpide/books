# Global Variables 요약
Jlox 에서 전역변수와 지역변수를 구현할 때, 각 범위에 대한 환경의 체인을 사용했다. 구현은 깔끔했지만 느렸다. Clox 에서는 이와 다른 방식을 사용한다.
문장은 선언과 다른종류의 문장(print, control-flow, etc)으로 분류된다.
문법 규칙에서 declaration 은 statement 를 포함하고 있고 statement 는 block 을 포함하고 있다. block 안에서 declaration 을 사용할수 있음으로 각각의 문법 규칙의 파싱함수는 재귀적으로 호출될 것이다.
전역 변수를 사용하기 위해서는 선언, 접근, 할당이 필요하다.
컴파일러에서 각각의 문장은 다음과 같은 패스를 통해서 컴파일 된다.
```
declaration() → varDeclaration() → defineVariable() → OP_DEFINE_GLOBAL
declaration() → statement() → expressionStatement() → expression() → parsePrecedence() → variable() → namedVariable() → OP_SET_GLOBAL
                                                                                                                      ↘ OP_GET_GLOBAL
```
할당이 포함된 표현식을 컴파일 할 때, variable() 는 prefix 표현식 이지만, 그것을 둘러싸고 있는 표현식의 우선순위를 고려해야 한다. 이를 parsePrecedence 에서 canAssign 을 계산해서 전달하는 것으로 해결한다. 


# 문단별 흥미로운 내용
- JLox 에서는 전역변수와 지역변수에 같은 구현 테크닉을 사용했다. 각각의 범위에 대한 환경의 체인을 만들었다. 상태를 어떻게 관리하는지 배우기에 깔끔하고 간단 했지만,
  매번 블록에 들어가거나 함수를 호출할 때 매번 새로운 해시테이블을 항당하는 것은 매우 느렸다. 코드에서 변수가 얼마나 많이 사용되는지 생각해보면, 변수가 느려지면 모든게 다 느려진다.
  CLox 에서는 다른 방식을 사용한다.
- Lox 에서는 전역변수는 "동적으로 리졸빙 된다", 지역변수는 사용되기전에 정의되어야 한다.
```
fun showVariable() {
  print global;
}

var global = "after";
showVariable();
```
## 21.1 Statements
- 문장은, 선언과 다른 종류의 문장(print, control-flow, etc)로 분류된다.
- control flow statements 에서 declaration 을 허용하지 않지만, declaration 은 statement 를 포함하고 있고, statement 는 다시 block 을 포함하고 있다. block 은 declaration 을 사용할 수 있다.
  - 블록을 사용하면 “선언문(declaration statement)”처럼 우선순위가 낮은 구문을, 원래는 “비선언문(non-declaring statement)”처럼 우선순위가 높은 구문만 허용되는 위치에 넣을 수 있다.
  - block 이 declarations 을 포함할 수 있고 control flow statements 가 다른 statements 를 포함 할 수 있음으로 declarations() 과 statements() 함수는 재귀적으로 호출될 것이다.
```c
static void declaration() {
  statement();
}
```
### 21.1.1 Print statements
- I think short verb-named functions like this make the parser easier to read.
- stack effect: 인스트럭션이 스택을 어떻게 변화시키는지에 대한 묘사. (ex, OP_ADD 의 stack effect 는 -1)
### 21.1.2 Expression statements
- expression statement 는 표현식을 평가하고 그 결과를 버린다. (OP_POP 인스트럭션을 emit 한다.)    - 할당에서 평가된 표현식은 아무튼 스택에 올라간 상태고, 할당식이 포인터만 저장하나?
### 21.1.3 Error synchronization

## 21.2 Variable Declarations
- 변수 선언을 위해서는 다음과 같은 세가지 오퍼레이션이 필요하다.
  - var 문장으로 변수 선언하기
  - identifier 표현식으로 변수의 값에 엑세스 하기
  - 온재하는 변수에 assignment 표현식으로 값 저장하기
- 변수 선언에서, constant table 에 string 으로 변수 이름을 저장한다. 저장된 인덱스는 OP_DEFINE_GLOBAL 인스트럭션과 함께 chunk 에 쓰여진다.
```
static uint8_t identifierConstant(Token* name) {
  return makeConstant(OBJ_VAL(copyString(name->start, name->length)));
}
```
```
static void defineVariable(uint8_t global) {
  emitBytes(OP_DEFINE_GLOBAL, global);
}
```
- compiler 에서 OP_DEFINE_GLOBAL 과, string 의 주소를 chunk 에 쓴다.
  vm 에서 OP_DEFINE_GLOBAL 을 인터프리트 할 때, 이름 string 을 읽고, stack 에서 값을 하나 읽어서(선언의 우변은 상수든, 표현식이든 이미 평가되어서 stack 에 올라가있다.) 그것을 globals 에 쓴다.  

※ OP_CONSTANT 는 할당이랑 관계없이 독립적으로 코드상에 리터럴로 값을 표현한 것의 컴파일 결과이다.
## 21.3 Reading Variables
- 선언의 경우 최상위에서 TOKEN_VAR 를 매치하는걸로 파싱이 되지만, 전역변수 엑세스의 경우 expression 에서 parsePrecedence 으로의 코드 패스를 가진다. 
- compiler 에서 OP_GET_GLOBAL 과, string 의 주소를 chunk 에 쓴다.
  vm 에서 OP_GET_GLOBAL 를 인터프리트 할 때, 이름 string 을 읽은다음 globals 에서 이름 으로 값을 읽은 후에 stack 에 push 한다.       

## 21.4 Assignment 
- bytecode VM 은 싱글 패스 컴파일러를 사용한다. 약간의 구문을 인지하자마자 그것에 대한 바이트 코드를 작성하는데 이는 할당에 적합하지 않다.
  다음과 같은 표현식에서 beverage 를 getter 가 아닌 setter 로 컴파일 해야하는지는 다행히도 = 을 보자마자 알 수 있다.
`menu.brunch(sunday).beverage = "mimosa";`
- 할당을 인식하는 아이디어는 할당의 대상이 될 수 있는 표현식을 컴파일 할때, 다음에 '=' 토큰이 있는지도 확인하는 것 이다. 만약 있다면 할당이나 setter 로 그것을 컴파일 할 수 있다.
- OP_SET_GLOBAL 의 인터프리팅은 OP_DEFINE_GLOBAL 과 비슷하다. 하지만 할당은 표현식 임으로 stack 에서 값을 pop 하지 않는다.
`b = (a = 5) + 2;` `a = 5, b = 7`
- `a * b = c + d;` 를 파싱한 다고 할때(`a * b`에 할당이 구문 오류 라고 할지라도 ) Lox 문법에서 `=` 는 가장 낮은 우선순위를 가짐으로 1 처럼 파싱되어야 하지만 현재의 variable()의 구현에서는 2 처럼 파싱된다.
![1](ast-good.png)
![2](ast-bad.png)
  - 만약 변수가 infix 연산자의 우변이거나, unary 연산자의 피연산자인 경우, 해당 표현식은 `=` 를 나중에 파싱하도록 표현식의 우선순위를 고려하도록 variable() 을 변경해야 한다.
    - 재귀적으로 variable() 이 호출될 때 canAssign 플래그를 넘기는 것으로 이 문제를 해결한다.
    - variable() 이 높은 우선순위의 표현식에 중첩되어 있을때, canAssign 은 false 가 되고 `=` 는 무시된다.
- 중위 표현식만 우선순위를 가진다. 표현식이 다른 표현식의 조합으로 이루어 짐으로 어떤 표현식을 먼저 컴파일할지 정해야한다. variable 은 접두 표현식을 파싱하는 함수이지만, 그것을 둘러싸고 있는 표현식의 우선순위를 고려해야 한다.

## Challenges
- 1. 변수 이름 자체를 constant table 에 저장한다. 할당에서 변수가 언급될 때도 변수를 다시 constant table 에 저장한다. 이러한 비효율을 해결하는 방법은?
 - String Interning 메카니즘을 구현한다.
- 2. 좋은 hash table 을 사용해도 이름으로 전역변수에 접근하는 것은 꽤 느리다. 더 효율적인 방법이 있는가?
- 3. Lox 의 REPL 에서 unknown 전역 변수에 대한 참조를 가지는 함수를 작성할 수 있다. Lox 의 스크립트에서 컴파일러는 전체 스크립트에 접근 할 수 있고, 
아래와 같은 프로그램에서 oops 가 정의되지 않았을을 정적으로 알 수 있다. 그리고 useVar() 호출이 없기 때문에 런타임 에러도 발생하지 않는다.  
이런 경우, 이것을 컴파일 에러로 알려야 할까? 다른 언어는 어떨까? 
```
fun useVar() {
print oops;
}

var ooops = "too many o's!";
```
 - 해야한다. 왜냐하면 실수 이외에 다른 의도가 있다고 볼 수 없기 때문에, 가능한 빨리 실수를 알리는게 좋다.
 - JavaScript 는 에러가 발생하지 않는다. TypeScript 컴파일 단계에서 에러를 돌려준다.
   - JavaScript 의 ESLint 를 사용하면 정적 분석을 통해서 에러를 돌려준다.