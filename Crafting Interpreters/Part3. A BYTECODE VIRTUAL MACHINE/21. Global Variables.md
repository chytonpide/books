# Global Variables 요약


# 문단별 흥미로운 내용
- JLox 에서는 전역변수와 지역변수에 같은 구현 테크닉을 사용했다. 각각의 범위에 대한 환경의 체인을 만들었다. 상태를 어떻게 관리하는지 배우기에 깔끔하고 간단 했지만,
  매번 블록에 들어가거나 함수를 호출할 때 매번 새로운 해시테이블을 항당하는 것은 매우 느렸다. 코드에서 변수가 얼마나 많이 사용되는지 생각해보면, 변수가 느려지면 모든게 다 느려진다.
  CLox 에서는 다른 방식을 사용한다.
- Lox 에서는 전역변수는 "동적으로 리졸빙 된다", 지역변수는 사용되기전에 정의되어야 한다.
```
fun showVariable() {
  print global;
}

var global = "after";
showVariable();
```
## 21.1 Statements
- 문장은, 선언과 다른 종류의 문장(print, control-flow, etc)로 분류된다.
- control flow statements 에서 declaration 을 허용하지 않지만, declaration 은 statement 를 포함하고 있고, statement 는 다시 block 을 포함하고 있다. block 은 declaration 을 사용할 수 있다.
  - 블록을 사용하면 “선언문(declaration statement)”처럼 우선순위가 낮은 구문을, 원래는 “비선언문(non-declaring statement)”처럼 우선순위가 높은 구문만 허용되는 위치에 넣을 수 있다.
  - block 이 declarations 을 포함할 수 있고 control flow statements 가 다른 statements 를 포함 할 수 있음으로 declarations() 과 statements() 함수는 재귀적으로 호출될 것이다.
```c
static void declaration() {
  statement();
}
```
### 21.1.1 Print statements
- I think short verb-named functions like this make the parser easier to read.
- stack effect: 인스트럭션이 스택을 어떻게 변화시키는지에 대한 묘사. (ex, OP_ADD 의 stack effect 는 -1)
### 21.1.2 Expression statements
- expression statement 는 표현식을 평가하고 그 결과를 버린다. (OP_POP 인스트럭션을 emit 한다.)    - 할당에서 평가된 표현식은 아무튼 스택에 올라간 상태고, 할당식이 포인터만 저장하나?
### 21.1.3 Error synchronization


