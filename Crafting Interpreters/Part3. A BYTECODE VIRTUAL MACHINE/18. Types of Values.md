# Types of Values 요약
tagged union 이라는 자료 구조를 활요해서 Lox 의 값(타입과 값자체) 을 표현한다.
사용자 코드가 bytecode 로 컴파일 되고 우리가 정의한 Value 타입으로 청크에 저장된다. vm 에서 청크를 인터프리팅(실행) 할때 이를 적잘한 c 타입으로 변환해줘야 한다.
이를 위해 몇가지 메크로들을 정의한다.
숫자 값을 다루는 코드를 변경한다. 이제 컴파일 결과는 double 이 아닌 Value 로 청크에 저장된다.

새로운 리터럴 두가지를 추가한다 true, false, 그리고 nil 이다.
기존 OP_CONSTANT 를 활용할 수도 있지만 성능을 위해 전용 옵코드 OP_NIL, OP_TRUE, OP_FALSE, 를 추가한다.
compiler 의 rules[]에 토큰에 대응하는, 순서와, unary 함수를 설정한 후, unary 함수가 적절한 bytecode 를 emit 하도록 한다.

논리 부정 연산자를 추가한다. 옵코드로 OP_NOT 을 추가한다.
compiler 의 rules[]에 토큰에 대응하는, 순서와, unary 함수를 설정한 후, unary 함수가 적절한 bytecode 를 emit 하도록 한다.
vm 에서 논리 부정 연산자를 인터프리팅 할 때는, falsiness 를 확인하고 true, false 값을 만들어낸다. 
lox 에서는 `nil` 과 `false` 만 falsey 다.

동등과 비교 연산자도 추가한다. 비교에는 <=, >=, != 와 같은 연산도 있지만 <, >, == 만으로 동일한 의미를 표현할 수 있음으로   
옵코드 OP_EQUAL, OP_GREATER, OP_LESS 만을 추한다.
마찬가지로 compiler 의 rules[]에 토큰에 대응하는, binary 함수를 설정한 후, binary 함수가 적절한 bytecode 를 emit 하도록 한다.



# 문단별 흥미로운 내용
- 전체 실행 구조
  - main.runFile -> vm.interpret -> compiler.compile //청크에 bytecode 기록 -> vm.run//bytecode 실행
- 값의 표현방식이 어떻게 서로 다른 타입들을 동적으로 처리할 수 있게 되는지 배운다.
## 18.1 Tagged Unions
- C 에서는 낮은 비트 부터 데이터 스트럭쳐를 만들 수 있다. 하지만 또 그렇게 해야한 한다. C 관점에서 세계는 구분되지 않은 바이트 배열이다. 몇 바이트를 사용할지 어떻게 의미를 붙일지는 우리가 해야하는 일이다.
- 값의 표현을 위해서는 다음의 두가지 질문에 답해야 한다. "값의 타입을 어떻게 표현할 것인가?", "값 자체를 어떻게 저장해야 할까?" 이를 tagged union 이라는 자료구조로 해결한다.
```c
typedef struct {
  ValueType type;
  union {
    bool boolean;
    double number;
  } as; 
} Value;
```
- 여기서 type 의 개념은 VM 의 것이지, user 의 것이 아니다. 유저가 정의한 타입은 VM 에서 전부 instance 라는 타입이 된다.
- 현재 우리가 정의한 값 타입은 모두 불변(immutable) 이다. 그래서 위 자료 구조로도 충분하다.
## 18.2 Lox Values and C Values
- 메크로 함수들을 이용해서 Lox 의 다이나믹 월드에서 C 의 스태틱 월드간에 데이터를 이동시킬 수 있다.
  - 전체 실행구조
    - main.runFile -> vm.interpret -> compiler.compile //청크에 bytecode 기록 -> vm.run//bytecode 실행
      - compiler.compile 실행구조
        - advance() 실행으로 첫 토큰을 준비하고, 첫 컴파일 expression() 을 실행 
        - compiler.parsePrecedence 의 재귀적인 루프에서 advance() 실행, 그 안에서 scanner.scanToken 을 실행하고 Parser 에 새로운 token 이 계속 해서 설정됨. 
        - 토큰을 식별하면 complier 의 number() 가 실행된다. number() 중간 자료구조인 Lox 의 Value 를 chunk 에 쓴다.
## 18.3 Dynamically Typed Numbers
### 18.3.1 Unary negation and runtime errors
### 18.3.2 Binary arithmetic operators
## 18.4 Two New Types
- 컴파일러가 true, false, nil 리터럴을 다룰 수 있게 한다. true, false 를 number 리터럴을 다룰 때 처럼 OP_CONSTANT 를 사용하는 방법도 있겠지만, 상수테이블을 사용하지 않고 바로 리터럴을 stack 푸시할 수 있는 전용 opcode 를 정의한다.
```c
OP_NIL,
OP_TRUE,
OP_FALSE,
```
- 컴퍼일러에 파싱을 구현하고, 
```c
static void literal() {
  switch (parser.previous.type) {
    case TOKEN_FALSE: emitByte(OP_FALSE); break;
    case TOKEN_NIL: emitByte(OP_NIL); break;
    case TOKEN_TRUE: emitByte(OP_TRUE); break;
    default: return; // Unreachable.
  }
}
```
- vm 에 시멕틱을 구현한다.
```c
case OP_NIL: push(NIL_VAL); break;
case OP_TRUE: push(BOOL_VAL(true)); break;
case OP_FALSE: push(BOOL_VAL(false)); break;
```
### 18.4.1 Logical not and falsiness
### 18.4.2 Equality and comparison operators
- OP_EQUAL 를 인터프리팅 할 때, memcmp() 를 사용해서 Value 를 직접 비교하는것은 Value 자료구조에 패딩이 있기 때문에 불가하다.
- We have one missing built-in type with its own literal form: strings. Those are much more complex because strings can vary in size. 

## Challenges
- OP_SUBTRACT 를 OP_NEGATE 와 OP_ADD 를, compiler 가 emit 하도록  변경할 수 있다.
- OP_GREATER_EQUAL, OP_LESS_EQUAL 의 옵코드를 추가한 후, vm 의 BINARY_OP 에 <=, >= 를 넘겨준다.
  





