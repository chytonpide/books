# Scanning on Demand 요약
와이어링　→　스캐너구현

# 문단별 흥미로운 내용
## Spinning Up the Interpreter
- fopen, malloc, fread 가 조용히 실패할 수 있으니 에러를 다뤄야한다. (fseek, ftell, rewind 도 이론적으로는 실패할 수 있지만 다루지 않는다. 적절한 수준 유지!)
### Opening the compilation pipeline
### The Scanner scans

## A Token at a Time (한번에 토큰 하나씩)
- jlox 에서는 소스코드 전체를 스캔해서 token 리스트를 만들었다. C 에서 그렇게 하려면 자료구조 정의와 메모리 관리에 많은 코드를 작성해야 한다.
어떤 시점에서 컴파일러는 한두개의 토큰만을 필요로 함으로(lox의 문법은 하나의 토큰 앞서보기 만을 요구한다.) 가장 간단한 해결책은 컴파일러가 요구할때 까지 토큰을
스캔하지 않고 필요할때 값으로 넘겨주는 것 이다. 이렇게 하는것은 동적 할당같은건 필요없이 C 스택을 위에서 전달한다.
- jlox 에서는 스캐닝 에러를 직접 처리했지만, clox 에는 합성 에러 토큰을 컴파일러에 전달하고 이것을 전달 받아서 컴파일러가 에러 리커버리를 시작한다.
- 토큰의 표현에 있어서 jlox 에서 표현이 lexme 을 가지고 있었지만, clox 에서는 string 을 위해서 메모리 관리를 해야함으로, 소스코드의 포인터를 가지도록 한다. (당연히 메모리에 원본 소스코드가 계속 올라가있는 상태여야 한다.)
### Scanning tokens