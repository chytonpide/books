# Calls and Functions 요약



# 문단별 흥미로운 내용
## 24.1 Function Objects
- Function 의 표현을 먼저 정의하자. VM 입장에서 보면 function 은 뭘까? 함수는 실행 가능한 본체를 가지고 이는 바이트 코드이다.
  함수를 포함한 프로그램을 하나의 거대한 chunk 로 만들 수도 있지만 clox 에서는 조금더 추상화하여 각 함수가 자신의 chunk 를 가지도록 표현한다.
## 24.2 Compiling to Function Objects
- We also have a little FunctionType enum. This lets the compiler tell when it’s compiling top-level code versus the body of a function. Most of the compiler doesn’t care about this—that’s why it’s a useful abstraction—but in one or two places the distinction is meaningful.
- Every place in the compiler that was writing to the Chunk now needs to go through that function pointer. Fortunately, many chapters ago, we encapsulated access to the chunk in the currentChunk() function. We only need to fix that and the rest of the compiler is happy.
- ObjFunction 는 런타임의 표현이지만, 컴파일 타임에 생성된다. string 이나 number 리터럴 처럼 생각하면 된다. 컴파일 타임과 런타임간의 가교 역할을 한다.
- 최상위 유저의 코드를 암시적인 function 으로 감싸도록 변경하는것으로 compiler 의 진임점인 compile() 함수는 다음과 같이 변경된다. 
  - compile()
    - initCompiler(): compiler 구조체 초기화, 전역 current 에 compiler 셋팅
    - while - declaration(): 실제 컴파일 수행. currentChunk() 가 &current->function->chunk 를 가르킴으로 현재 함수의 chunk 에 바이트 코드를 씀
    - endCompiler(): current 에서 함수만 추출해서 돌려줌.
## 24.3 Call Frames
### 24.3.1 Allocating local variables
- compiler 는 로컬변수를 위한 스택 슬롯을 가지고 있다. 근데 여러 함수에 로컬 변수가 분산되어 있는 문제는 어떻게 해결할 수 있을까?
  - 각각의 함수라 로컬변수를 위한 공간을 가지도록 하는 방법이 있다. 포트란에서는 이방법을 사용했다. 하지만 재귀 호출을 지원할 수 없었다. 
    - jlox 에서는 런타임에 동적으로 로컬 변수를 위한 공간을 할당했다.
  - 여러 함수에 걸쳐서 로컬변수가 정의된다고 하더라도, 나중에 정의된 변수가 먼저 정의된 변수보다 폐기된다는 원리를 따르고, 따라서 여기에도 스택을 사용할 수 있다.
    같은 함수가 여러번 호출 될때, 두번째 호출에서의 로컬 변수의 슬롯은 첫번째 호출에서의 슬롯과 다를 수 있지만, 함수 내부에서의 정의 순서는 같다.
    따라서 함수 호출시에 첫번째 슬롯을 기억해두고, 그 슬롯을 기준으로한 상대적인 슬롯 인덱스를 사용하는것으로 정확하게 로컬변수에 접근할 수 있다.
    - 함수의 로컬 변수가 시작되는 이 위치를 기록해 두는 값의 이름은 프레임 포인터(frame pointer)다.
    - 함수의 로컬 별수들이 저장되는 스택의 토막을 콜 프레임(call frame)이다.
### 24.3.2 Return addresses
- 함수가 종료되면 돌아갈 위치가 필요하다 이를 return address 라고 부른다. 함수는 재귀 호출될 수 있고 이때마다 돌아갈 위치는 다른다. 따라서 return address 는 함수의 특성이 아니라 각각의 발동(invocation)의 특성이다.
### 24.3.3 The call stack
- 각 함수의 발동(invocation)마다 스택의 어디부터 그 함수의 지역변수가 시작되는지, 콜러가 어디부터 계속해야할지에 대한 정보가 필요하다.
  진행되고 있는 함수의 호출을 CallStack 으로 표현한다. 따라서 함수가 호출될 때마다 이 구조체가 생성된다.
```c
typedef struct {
  ObjFunction* function;
  uint8_t* ip;            // 콜러가 돌아가야할 자신의 ip 를 저장하도록 한다.
  Value* slots;
} CallFrame;
```
- 함수 호출도 스택의 시멘틱을 따름으로 함수 호출또한 스택에 저장한다.
- callFrame 에서 ip를 읽도록 ip 읽기 메크로들을 수정한다. 지역변수 및 ip 조작의 op_code의 인터프리팅의 경우도 스택에서 직접 읽는것이 아니라, 콜스택의 slots 에서 읽어도록 한다.
- 이렇게 해서 기능 추가를 위한 인프라 스트럭쳐가 준비된다.
## 24.4 Function Declarations
### 24.4.1 A stack of compilers
- 록스에서는 함수안에 함수를 정의할 수 없다. 따라서 사용자 정의 함수에서 한단계만 위로 올라갈수 있고 그것은 top-level 함수이다.
  - 컴파일타임에 모든 함수 본체는 OP_CONSTANT 로 emit 되고, 함수의 이름은 OP_DEFINE_GLOBAL 로 emit 된다.
  - 런타임에 OP_CONSTANT 는 스택에 값을 push 하고 OP_DEFINE_GLOBAL 은 값을 읽어와서 vm 의 table 에 set 한다.
- 컴파일러가 사용하는 표현의 계층
  - Chunk(constants)->ObjFunction->Compiler(locals): compiler 가 링크드 리스트 형태로 연결된다.
- vm 사용하는 표현의 계층
  - ObjFunction->CallFrame(slots):stack 형태로 vm 에 저장된다.->VM
- funDeclaration()
  - parseVariable(): 변수 이름 파싱
    - 전역변수로 파싱한다. 따라서 declareVariable() 는 무시된다. 
    - chunk 에 OP_CONSTANT 와 함께 상수로 function 이름을 설정한다.
  - function(): 함수 파싱,
    - 컴파일러를 초기화한다.
      - 이전 compiler 를 enclosing 에 저장한다.
      - current 가 새 compiler 로 바뀐다.
    - 블록을 function 의 chunk 에 설정한다.
    - 컴파일러를 종료한다.
      - current 가 상위의 enclosing 으로 바뀐다.
    - function 의 chunk 에 OP_CONSTANT 와 함께 상수로 function 본체를 설정한다. 
  - defineVariable(global): 변수 정의.
    - 전역변수를 정의한다. 따라서 markInitialized() 는 무시된다.
    - OP_DEFINE_GLOBAL 과 함께 엑세스할 전역변수의 위치 global 를 설정한다.
### 24.4.2 Function parameters
## 24.5 Function Calls
- 함수 호출은 일종의 중위 표현식이다.
  - f(x) : f는 operator, x 는 피연산자
- 함수 호출 파싱
  - expressionStatements()
  - expression()
  - parsePrecedence(PREC_ASSIGNMENT)
    - advance(): // identifier 소비
    - type: TOKEN_IDENTIFIER
    - variable(true)
      - namedVariable(fn-name, true): emitBytes(OP_GET_GLOBAL, constants 주소)
    - advance(); // 괄호 소비.
    - call(true)
      - argumentList(
      - emitBytes(OP_CALL, argCount);
### 24.5.1 Binding arguments to parameters
- 본체를 실행하기 직전에 스택에는 해당 함수의 argument 가 평가되어서 올라가 있고 이는 정확하게 parameter 순서와 일치하기 때문에 추가적인 바인딩작업은 필요없다.
  - chunk 에는, OP_CALL 과 함께 argument 의 개수가 설정되어있음으로, 이를 이용해서 스택에서 얼마나 거슬러 올라가야 스택에서 함수를 찾을 수 있는지 알 수 있다.
### 24.5.2 Returning from functions
- OP_RETURN 의 인터프리팅:  함수 호출의 결과값을 임시로 저장한후, CallFrame 을 파기하면서 stack 을 원상복귀 시킨뒤, 결과값을 stack 에 push 한다.
## 24.6 Return Statements
- JLox 에서는 중첩된 AST 에서 리턴을 할 때 예외 메카니즘을 사용했지만, CLox 에서는 컴파일은 재귀적으로 하지만 런타임에서의 바이트코드의 디스패치는 flat 하다.
## 24.7 Native Functions
- native function 전혀 다른 머시너리를 필요로하고 따라서 그 표현또한 다르다.
```c
typedef Value (*NativeFn)(int argCount, Value* args);

typedef struct {
  Obj obj;
  NativeFn function;
} ObjNative;
```
- native 함수의 호출에서는 CallFrame 의 생성등을 필요없다. 포인터를 통해서 함수를 호출하고 결과를 받은 후 stack 에 올린다.  
- native 함수는 당연하지만 compile 과정이 없다. vm 이 실행 될때 vm 상에 초기화 된다.
## Challenges

