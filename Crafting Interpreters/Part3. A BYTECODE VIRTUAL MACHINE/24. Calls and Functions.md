# Calls and Functions 요약



# 문단별 흥미로운 내용
## 24.1 Function Objects
- Function 의 표현을 먼저 정의하자. VM 입장에서 보면 function 은 뭘까? 함수는 실행 가능한 본체를 가지고 이는 바이트 코드이다.
  함수를 포함한 프로그램을 하나의 거대한 chunk 로 만들 수도 있지만 clox 에서는 조금더 추상화하여 각 함수가 자신의 chunk 를 가지도록 표현한다.
## 24.2 Compiling to Function Objects
- We also have a little FunctionType enum. This lets the compiler tell when it’s compiling top-level code versus the body of a function. Most of the compiler doesn’t care about this—that’s why it’s a useful abstraction—but in one or two places the distinction is meaningful.
- Every place in the compiler that was writing to the Chunk now needs to go through that function pointer. Fortunately, many chapters ago, we encapsulated access to the chunk in the currentChunk() function. We only need to fix that and the rest of the compiler is happy.
- ObjFunction 는 런타임의 표현이지만, 컴파일 타임에 생성된다. string 이나 number 리터럴 처럼 생각하면 된다. 컴파일 타임과 런타임간의 가교 역할을 한다.
- 최상위 유저의 코드를 암시적인 function 으로 감싸도록 변경하는것으로 compiler 의 진임점인 compile() 함수는 다음과 같이 변경된다. 
  - compile()
    - initCompiler(): compiler 구조체 초기화, 전역 current 에 compiler 셋팅
    - while - declaration(): 실제 컴파일 수행. currentChunk() 가 &current->function->chunk 를 가르킴으로 현재 함수의 chunk 에 바이트 코드를 씀
    - endCompiler(): current 에서 함수만 추출해서 돌려줌.
## 24.3 Call Frames
### 24.3.1 Allocating local variables
- compiler 는 로컬변수를 위한 스택 슬롯을 가지고 있다. 근데 여러 함수에 로컬 변수가 분산되어 있는 문제는 어떻게 해결할 수 있을까?
  - 각각의 함수라 로컬변수를 위한 공간을 가지도록 하는 방법이 있다. 포트란에서는 이방법을 사용했다. 하지만 재귀 호출을 지원할 수 없었다. 
    - jlox 에서는 런타임에 동적으로 로컬 변수를 위한 공간을 할당했다.
  - 여러 함수에 걸쳐서 로컬변수가 정의된다고 하더라도, 나중에 정의된 변수가 먼저 정의된 변수보다 폐기된다는 원리를 따르고, 따라서 여기에도 스택을 사용할 수 있다.
    같은 함수가 여러번 호출 될때, 두번째 호출에서의 로컬 변수의 슬롯은 첫번째 호출에서의 슬롯과 다를 수 있지만, 함수 내부에서의 정의 순서는 같다.
    따라서 함수 호출시에 첫번째 슬롯을 기억해두고, 그 슬롯을 기준으로한 상대적인 슬롯 인덱스를 사용하는것으로 정확하게 로컬변수에 접근할 수 있다.
    - 함수의 로컬 변수가 시작되는 이 위치를 기록해 두는 값의 이름은 프레임 포인터(frame pointer)다.
    - 함수의 로컬 별수들이 저장되는 스택의 토막을 콜 프레임(call frame)이다.
### 24.3.2 Return addresses ... 계속
    