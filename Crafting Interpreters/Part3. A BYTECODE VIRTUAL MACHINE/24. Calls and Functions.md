# Calls and Functions 요약

Function Infrastructures: 함수의 인프라 스트럭쳐를 먼저 구현한다. 함수의 표현으로 ObjFunction 을 정의한다. ObjFunction 는 vm 이 실행할 수 있는 chunk 를 가진다.
compile 결과는 최상위 ObjFunction 이다. 컴파일러는 ObjFunction 의 chunk 에 바이트 코트를 에밋한다.

컴파일러는 지역변수를 위한 슬롯을 할당한다. 프로그램의 여러 함수에 지역변수가 나누어져 있는 경우 스택을 어떻게 활용해야 할까?
스택에 지역변수를 저장하는 메카니즘은 동일하다. 따라서 함수 호출시에 첫번째 슬롯을 기억해두고, 그 슬롯을 기준으로한 상대적인 슬롯 인덱스를 사용하는것으로 정확하게 로컬변수에 접근할 수 있다.
이렇게 함수의 지역변수(런타임의 인수)가 저정되는 스택의 공간을 call frame 이라고 한다.

런타임에서 사용되는 CallFrame 이라는 표현을 정의한다. 여기에는 콜러가 돌아가야할 ip 와 함수의 지역변수 ObjFunction 을 필드로 가진다.
vm 는 CallFrame 의 stack 을 필드로 가지고(call stack) 함수 호출 마다 이를 생성 소멸 시킨다.

ObjFunction, CallFrame 의 표현을 정의하고 컴파일러와 vm에 적절한 시멘틱을 만드는 것으로 기능 구현을 위한 인프라스트럭처의 준비가 완료된다.

Function Declarations : 각각의 함수는 각자의 컴파일러에 의해서 컴파일 된다. 컴파일러들은 링크드리스트 형태로 이어진다. 록스에서는 함수안에 함수를 정의할 수 없다. 
따라서 사용자 정의 함수에서 한단계만 위로 올라갈수 있고 그것은 top-level 함수이다. 컴파일타임에 모든 함수 본체는 OP_CONSTANT 로 emit 되고, 함수의 이름은 OP_DEFINE_GLOBAL 로 emit 된다.
(endCompiler 에서 current 가 상위 compiler 로 바뀐뒤, 그 함수의 chunk 에 constant 로 함수 본체를 쓴다!)
런타임에 OP_CONSTANT 는 스택에 값을 push 하고 OP_DEFINE_GLOBAL 은 값을 읽어와서 vm 의 table 에 set 한다.
함수의 파라미터는 지역변수 컴파일과 같다.

Function Calls : 함수 호출은 일종의 중위 표현식이다. parsePrecedence() 의해 파싱되고, OP_GET_GLOBAL 과 함수 본체 constants 주소가 emit 된 후에 OP_CALL 이 emit 된다.
런타임에서 OP_CALL 은 이미 OP_GET_GLOBAL 에 의해서 stack 에 설정된 함수 본체 constants 주소에 접급해서 함수를 call 한다.
이때 새로운 CallFrame 이 생성되고 run() 함수의 캐시된 frame 이 프레임으로 교체된다.

Return Statements : 컴파일 타임에 OP_RETURN 를 emit 한다. 
런타임에서 OP_RETURN run() 함수의 캐시된 frame 이 이전 frame 으로 변경되고, 이전 함수가 사용하던 stack 공간을 모두 파기하면서 stackTop 도 변경된다.

Native Functions: ObjNative 라는 표현을 정의한다. vm 상에 native 함수를 정의할 수 있는(전역변수로 설정하는) 함수를 만들고 vm 실행 시에 실행하는걸로 셋팅한다.


# 문단별 흥미로운 내용


## 24.1 Function Objects
- Function 의 표현을 먼저 정의하자. VM 입장에서 보면 function 은 뭘까? 함수는 실행 가능한 본체를 가지고 이는 바이트 코드이다.
  함수를 포함한 프로그램을 하나의 거대한 chunk 로 만들 수도 있지만 clox 에서는 조금더 추상화하여 각 함수가 자신의 chunk 를 가지도록 표현한다.

## 24.2 Compiling to Function Objects
- We also have a little FunctionType enum. This lets the compiler tell when it’s compiling top-level code versus the body of a function. Most of the compiler doesn’t care about this—that’s why it’s a useful abstraction—but in one or two places the distinction is meaningful.
- Every place in the compiler that was writing to the Chunk now needs to go through that function pointer. Fortunately, many chapters ago, we encapsulated access to the chunk in the currentChunk() function. We only need to fix that and the rest of the compiler is happy.
- ObjFunction 는 런타임의 표현이지만, 컴파일 타임에 생성된다. string 이나 number 리터럴 처럼 생각하면 된다. 컴파일 타임과 런타임간의 가교 역할을 한다.
- 최상위 유저의 코드를 암시적인 function 으로 감싸도록 변경하는것으로 compiler 의 진임점인 compile() 함수는 다음과 같이 변경된다. 
  - compile()
    - initCompiler(): compiler 구조체 초기화, 전역 current 에 compiler 셋팅
    - while - declaration(): 실제 컴파일 수행. currentChunk() 가 &current->function->chunk 를 가르킴으로 현재 함수의 chunk 에 바이트 코드를 씀
    - endCompiler(): current 에서 함수만 추출해서 돌려줌.


## 24.3 Call Frames
### 24.3.1 Allocating local variables
- compiler 는 로컬변수를 위해 스택 슬롯을 할당한다. 근데 여러 함수에 로컬 변수가 분산되어 있는 문제는 어떻게 해결할 수 있을까?
  - 각각의 함수라 로컬변수를 위한 공간을 가지도록 하는 방법이 있다. 포트란에서는 이방법을 사용했다. 하지만 재귀 호출을 지원할 수 없었다. 
    - jlox 에서는 런타임에 동적으로 로컬 변수를 위한 공간을 할당했다.
  - 여러 함수에 걸쳐서 로컬변수가 정의된다고 하더라도, 나중에 정의된 변수가 먼저 정의된 변수보다 폐기된다는 원리를 따르고, 따라서 여기에도 스택을 사용할 수 있다.
    같은 함수가 여러번 호출 될때, 두번째 호출에서의 로컬 변수의 슬롯은 첫번째 호출에서의 슬롯과 다를 수 있지만, 함수 내부에서의 정의 순서는 같다.
    따라서 함수 호출시에 첫번째 슬롯을 기억해두고, 그 슬롯을 기준으로한 상대적인 슬롯 인덱스를 사용하는것으로 정확하게 로컬변수에 접근할 수 있다.
    - 함수의 로컬 변수가 시작되는 이 위치를 기록해 두는 값의 이름은 프레임 포인터(frame pointer)다.
    - 함수의 로컬 별수들이 저장되는 스택의 토막을 콜 프레임(call frame)이다.
### 24.3.2 Return addresses
- 함수가 종료되면 돌아갈 위치가 필요하다 이를 return address 라고 부른다. 함수는 재귀 호출될 수 있고 이때마다 돌아갈 위치는 다른다. 따라서 return address 는 함수의 특성이 아니라 각각의 발동(invocation)의 특성이다.
### 24.3.3 The call stack
- 각 함수의 발동(invocation)마다 스택의 어디부터 그 함수의 지역변수가 시작되는지, 콜러가 어디부터 계속해야할지에 대한 정보가 필요하다.
  진행되고 있는 함수의 호출을 CallStack 으로 표현한다. 따라서 함수가 호출될 때마다 이 구조체가 생성된다.
```c
typedef struct {
  ObjFunction* function;
  uint8_t* ip;            // 콜러가 돌아가야할 자신의 ip 를 저장하도록 한다.
  Value* slots;
} CallFrame;
```
- 함수 호출도 스택의 시멘틱을 따름으로 함수 호출또한 스택에 저장한다.
- callFrame 에서 ip를 읽도록 ip 읽기 메크로들을 수정한다. 지역변수 및 ip 조작의 op_code의 인터프리팅의 경우도 스택에서 직접 읽는것이 아니라, 콜스택의 slots 에서 읽어도록 한다.
- 이렇게 해서 기능 추가를 위한 인프라 스트럭쳐가 준비된다.


## 24.4 Function Declarations
### 24.4.1 A stack of compilers
- 록스에서는 함수안에 함수를 정의할 수 없다. 따라서 사용자 정의 함수에서 한단계만 위로 올라갈수 있고 그것은 top-level 함수이다.
  - 컴파일타임에 모든 함수 본체는 OP_CONSTANT 로 emit 되고, 함수의 이름은 OP_DEFINE_GLOBAL 로 emit 된다.
  - 런타임에 OP_CONSTANT 는 스택에 값을 push 하고 OP_DEFINE_GLOBAL 은 값을 읽어와서 vm 의 table 에 set 한다.
- 컴파일러가 사용하는 표현의 계층
  - Chunk(constants)->ObjFunction->Compiler(locals): compiler 가 링크드 리스트 형태로 연결된다.
- vm 사용하는 표현의 계층
  - ObjFunction->CallFrame(slots):stack 형태로 vm 에 저장된다.->VM
- funDeclaration()
  - parseVariable(): 변수 이름 파싱
    - 전역변수로 파싱한다. 따라서 declareVariable() 는 무시된다. 
    - chunk 에 OP_CONSTANT 와 함께 상수로 function 이름을 설정한다.
  - function(): 함수 파싱,
    - 컴파일러를 초기화한다.
      - 이전 compiler 를 enclosing 에 저장한다.
      - current 가 새 compiler 로 바뀐다.
    - 블록을 function 의 chunk 에 설정한다.
    - 컴파일러를 종료한다.
      - current 가 상위의 enclosing 으로 바뀐다.
    - function 의 chunk 에 OP_CONSTANT 와 함께 상수로 function 본체를 설정한다. 
  - defineVariable(global): 변수 정의.
    - 전역변수를 정의한다. 따라서 markInitialized() 는 무시된다.
    - OP_DEFINE_GLOBAL 과 함께 엑세스할 전역변수의 위치 global 를 설정한다.
### 24.4.2 Function parameters


## 24.5 Function Calls
- 함수 호출은 일종의 중위 표현식이다.
  - f(x) : f는 operator, x 는 피연산자
- 함수 호출 파싱
  - expressionStatements()
  - expression()
  - parsePrecedence(PREC_ASSIGNMENT)
    - advance(): // identifier 소비
    - type: TOKEN_IDENTIFIER
    - variable(true)
      - namedVariable(fn-name, true): emitBytes(OP_GET_GLOBAL, constants 주소)
    - advance(); // 괄호 소비.
    - call(true)
      - argumentList(
      - emitBytes(OP_CALL, argCount);
### 24.5.1 Binding arguments to parameters
- 본체를 실행하기 직전에 스택에는 해당 함수의 argument 가 평가되어서 올라가 있고 이는 정확하게 parameter 순서와 일치하기 때문에 추가적인 바인딩작업은 필요없다.
  - chunk 에는, OP_CALL 과 함께 argument 의 개수가 설정되어있음으로, 이를 이용해서 스택에서 얼마나 거슬러 올라가야 스택에서 함수를 찾을 수 있는지 알 수 있다.
### 24.5.2 Returning from functions
- OP_RETURN 의 인터프리팅:  함수 호출의 결과값을 임시로 저장한후, CallFrame 을 파기하면서 stack 을 원상복귀 시킨뒤, 결과값을 stack 에 push 한다.


## 24.6 Return Statements
- JLox 에서는 중첩된 AST 에서 리턴을 할 때 예외 메카니즘을 사용했지만, CLox 에서는 컴파일은 재귀적으로 하지만 런타임에서의 바이트코드의 디스패치는 flat 하다.
## 24.7 Native Functions
- native function 전혀 다른 머시너리를 필요로하고 따라서 그 표현또한 다르다.
```c
typedef Value (*NativeFn)(int argCount, Value* args);

typedef struct {
  Obj obj;
  NativeFn function;
} ObjNative;
```
- native 함수의 호출에서는 CallFrame 의 생성등을 필요없다. 포인터를 통해서 함수를 호출하고 결과를 받은 후 stack 에 올린다.  
- native 함수는 당연하지만 compile 과정이 없다. vm 이 실행 될때 vm 상에 초기화 된다.
## Challenges
- 1. ip 를 CallFrame 을 통해서 간접참조 하면 캐싱이 되지 않는다. 캐싱을 통한 성능 향상을 위해 ip 를 c의 register 지역변수에 저장해서 사용하도록 구현하라.
  - vm 에 ip 지역변수 추가. call 프레임 생성 시점과 종료시점에 (OP_CALL, OP_RETURN 의 인터프리팅 시점) vm 의 ip 를 변경한다.    
- 2. Native function 에 arity check 를 추가해라. 
  - ObjNative 에 arity 필드 추가, vm의 callValue 함수에서 argCount 와 ObjNative 의 arity 를 비교한다. 
- 3. Native function 에 잘못된 인수를 전달 했을때 적절히 runtime 에러가 발생하도록 해라.
  - vm 내의 native function 에서 c 함수를 호출하기전에 인수타입을 전부 검사하고 런타임 에러를 발생시킨다.
- 4. 편리하다고 생각하는 native function 을 추가하라.
  - scanf 같은 input 처리 함수

