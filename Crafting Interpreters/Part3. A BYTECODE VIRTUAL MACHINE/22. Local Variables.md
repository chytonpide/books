# Local Variables 요약
지역변수를 표현하기 위한 Compiler 자료구조를 정의하고 컴퍼일러가 상태를 관리하도록 한다.
이 자료구조는 지역변수의 이름을 배열로 관리한다.

블록 문장을 구현한다. 컴파일러에서 블록을 위한 op_code는 존재하지 않는다. 블록은 재귀적으로 코드가 컴파일 되도록 한다.
컴파일러는 블록을 컴파일 하면서 스코프에 관한 상태를 Compiler 에 기록한다.

지역 변수의 선언 기능을 구현한다. Compiler 의 스코프 상태를 활용해서 코드에 나타난 변순 선언이 지역변수인지 전역변수인지를 구분한다.
지역변수를 위한 op_code를 에밋하지 않고,  Compiler.locals 에 지역변수의 이름을 추가한다.
초기자의 값을 스택에 그대로 남아 있는데 이는 Compiler.locals 배열의 인덱스와 정확히 일치한다.
암묵적이지만 이렇게 함으로써 효율적으로 지역변수를 다룰 수 있다.

지역 변수의 엑세스와 할당 기능을 구현한다. 변수 토큰을 발견했을 때 컴파일러의 namedVariable 함수에서 로컬변수인지 전역변수인지를 판단해서 
해당하는 op_code 를 에밋한다.
Compiler.locals 에서 먼저 지역변수를 찾고, 없다면 전역변수로 판단한다. 이후 = 토큰의 유무로 할당인지 엑세스인지를 구분한다.

정의는 사용준비가 완료된것, 선언은 변수 선언표현으로 구분해서 지역변수가 정의되지 않은 상태에서 사용되는것을 방지한다.


# 문단별 흥미로운 내용
- 전역 변수는 컴파일 타임 이후에 resolved 된다. 성능을 위해서 자주사용되는 지역변수는 더 효율적인 방식으로 동작해야 한다. 
  지역변수는 lexical scope 의 성질을 가짐으로 컴파일 타임에 리졸브 할 수 있다.

## 22.1 Representing Local Variables
- 지역 변수를 스택에 저장할 수 있다. 로컬 변수는 선언 문장에 의해서만 만들어지고, 표현식 안에 문장이 내포 될 수 없음으로 표현식을 평가할때 스택의 쓰이는 값들이 간섭 하는 경우는 없다.
  즉 문장이 실행되는 동안에 스택에는 표현식 평가를 위한 임시 값이 있는 경우가 없다. (임시 값들은 지역 변수가 저장된 위쪽으로만 증가했다가 감소한다.)
  블록은 중첩되고, 블록이 끝나면 로컬변수는 제거 되어야 하는데, 이는 스택의 동작과 일치한다.
- 스택의 로컬 변수의 값을 저장한뒤, 스택의 포인터를 로컬 변수를 읽고 저장하는 바이트코드의 피연산자로 활용 하는것으로 로컬 변수 작업을 빠르게 처리할 수 있다.
- Compiler 라는 자료구조를 정의해서 지역변수의 상태를 관리한다.
## 22.2 Block Statements
- 블락 문장은 컴파일 될 때 스코프를 만들고, 문장이 포함하는 다른 문장을 재귀적으로 컴파일 되도록 한다. (따로 OP_CODE 를 emit 하지 않는다.)  
## 22.3 Declaring Local Variables
- 이미 var 로 시작하는 문장을 파싱하기 위한 varDeclaration() 를 가지 고 있음으로, 새로운 스코핑 시멘틱을 여기에 연결해야 한다.
![declaration](declaration.png)
  따라서 로컬 스코프인 경우, parseVariable() 에서는 locals 에 지역변수의 이름을 저장하고, 이름을 constant 로 저장하는 로직은 스킵되고, constant table 인덱스가 아닌 0 을 되돌려준다.   
  defineVariable() 에서는 OP_DEFINE_GLOBAL 를 emit 하지 않고 그대로 스킵된다.  
  지역 변수를 위해서 만드는 코드는 없다. 초기자에 의해 계산 된 값은 stack 의 오른쪽에 그대로 남게 되고 그대로 지역변수가 된다.
  결과적으로 locals 에 쌓인 이름의 인덱스와 stack 에 쌓인 값들의 인덱스가 일치하게 된다. 
- endScope() 에서 스코프에 포함되는 지역변수들을 폐기해야 하고 마찬가지로 stack 에서 그 값을 제거해야 함으로 OP_POP 을 emit 한다.
## 22.4 Using Locals
- namedVariable 에서 엑세스 또는 할당을 할때, 그것이 전역변수인지 지역변수인지를 판단한 후에 올바른 바이트코드를 emit 한다.
- 표현식은 값을 생성한다. 할당도 표현식 이고 할당의 값은 할당된 값 그 자체임으로 그 값은 스택에 그대로 남아있어야 한다. 아래 코드를 실행 할 수 있어야 한다.
```
b = a = 10
```
- 변수가 정의되지 않은 상태에서 변수를 참조하는 것을 막기 위해서, 선언과 정의를 구분한다. 선언은 스코프에 변수가 추가된것, 정의는 사용준비가 된 상태를 의미한다. 
- Clox 에서는 컴파일 단계에서 지역변수의 이름과 스택에 저장되는 값의 인덱스를 일치시키는 테크닉을 통해서, 런타임에 조회나 레졸루션이 필요하지 않도록 했다.
  (c 같은 경우에 정적 타입 언어이지만 타입체크 같은건 컴파일중에 이루어지고, 런타임에 모든 타입 표현이 지워지고 그냥 값비트들만 있다. 이로서 성능을 끌어 올린다.)
- Lox 에서 전역 변수는 “late bound” 된다.
  ※ Implicit Variable Declaration 은 var 등으로 선언하지 않고, 할당으로도 선언되는 것을 의미한다.

## CHALLENGES
1. 컴파일러에서 locals 의 선형 스캔을 하는데 더 효율적으로 할수 있나? 추가적인 복잡도가 가치가 있나?
로컬을 해시테이블에 저정한다. 지역변수는 가장 많이 사용됨으로 가치가 있다.
2. `var a = a;` 가 허용되는 언어와 그 이유는? 
javascript 의 var 그냥 legacy design flaw 처럼 보인다.
3. 많은 언어들이 재할당이 가능한 변수와 그렇지 못한 변수를 구분한다. lox 에 사용할 키워드를 선택하고 구현하라.
const, var, 명확하게 상수와 변수를 키워드로 사용한다. 
4. 256개 이상의 로컬 변수를 가질 수 있도록 변경하라.
slot 이 1byte 인게 문제 임으로, 컴파일러에서 namedVariable emit 할 때 slot 을 2byte 로 에밋하고, vm 에서도 마찬가지로 read2Byte() 로 slot 을 읽어오게 한다? 
