# Local Variables 요약


# 문단별 흥미로운 내용
- 전역 변수는 컴파일 타임 이후에 resolved 된다. 성능을 위해서 자주사용되는 지역변수는 더 효율적인 방식으로 동작해야 한다. 
  지역변수는 lexical scope 의 성질을 가짐으로 컴파일 타임에 리졸브 할 수 있다.

## 22.1 Representing Local Variables
- 지역 변수를 스택에 저장할 수 있다. 로컬 변수는 선언 문장에 의해서만 만들어지고, 표현식 안에 문장이 내포 될 수 없음으로 표현식을 평가할때 스택의 쓰이는 값들이 간섭 하는 경우는 없다.
  즉 문장이 실행되는 동안에 스택에는 표현식 평가를 위한 임시 값이 있는 경우가 없다. (임시 값들은 지역 변수가 저장된 위쪽으로만 증가했다가 감소한다.)
  블록은 중첩되고, 블록이 끝나면 로컬변수는 제거 되어야 하는데, 이는 스택의 동작과 일치한다.
- 스택의 로컬 변수의 값을 저장한뒤, 스택의 포인터를 로컬 변수를 읽고 저장하는 바이트코드의 피연산자로 활용 하는것으로 로컬 변수 작업을 빠르게 처리할 수 있다.
- Compiler 라는 자료구조를 정의해서 지역변수의 상태를 관리한다.
## 22.2 Block Statements
- 블락 문장은 컴파일 될 때 스코프를 만들고, 문장이 포함하는 다른 문장을 재귀적으로 컴파일 되도록 한다. (따로 OP_CODE 를 emit 하지 않는다.)  
## 22.3 Declaring Local Variables
- 이미 var 로 시작하는 문장을 파싱하기 위한 varDeclaration() 를 가지 고 있음으로, 새로운 스코핑 시멘틱을 여기에 연결해야 한다.
![declaration](declaration.png)
  따라서 로컬 스코프인 경우, parseVariable() 에서는 locals 에 지역변수의 이름을 저장하고, 이름을 constant 로 저장하는 로직은 스킵되고, constant table 인덱스가 아닌 0 을 되돌려준다.   
  defineVariable() 에서는 OP_DEFINE_GLOBAL 를 emit 하지 않고 그대로 스킵된다.  
  지역 변수를 위해서 만드는 코드는 없다. 초기자에 의해 계산 된 값은 stack 의 오른쪽에 그대로 남게 되고 그대로 지역변수가 된다.
  결과적으로 locals 에 쌓인 이름의 인덱스와 stack 에 쌓인 값들의 인덱스가 일치하게 된다. 
- endScope() 에서 스코프에 포함되는 지역변수들을 폐기해야 하고 마찬가지로 stack 에서 그 값을 제거해야 함으로 OP_POP 을 emit 한다.
## 22.4 Using Locals


현재 우리가 평범하다고 생각하는 언어의 문법 규칙이, 하드웨어 제한에 의해서 생겨난 것들이 많다.
예를들면, 블록, 로컬변수의 스코프 이런것들..