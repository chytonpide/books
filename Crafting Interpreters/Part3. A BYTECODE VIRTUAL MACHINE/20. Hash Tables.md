# Hash Tables 요약



# 문단별 흥미로운 내용
- 해시테이블의 진정한 힘은, 키가 얼마나 많든 상수시간에 값을 얻을 수 있다는 점이다.
## 20.1 An Array of Buckets
- 26개의 변수만 가질수 있다고 하면, 26개의 버킷만 준비하면 된다. 키 벨류 값이 할당된 버킷도 있지만 그렇지 않은 버킷이 있더라도 메모리 소비는 심하지 않다. 
  인덱스를 찾기도 쉽다. 키를 알파벳으로 사용하면 키가 주어졌을 때 a 를 뺀 값으로 인덱스를 찾을 수 있다. 헤시테이블은 여기에 해시함수, 동적크기조절, 충돌해결을 추가하지만, 
  여전히 직접 인덱싱 할 수 있는 연속적인 버킷 배열이라는 것은 변하지 않는다.
- 변수이름(키)을 8글자 까지 허용하면, 키를 그대로 index 로 변환하면 295,148 petabyte 의 버킷을 준비해야 한다. 이것은 비현실 적임으로 작은 배열 요소의 범위로 큰 수의 범위를 fold 해야한다.  
  이때 modulo 연산을 사용하면, 배열의 크기보다 작은 수의 범위로 키를 fold 할 수 있다. 자연히 이경우 index 의 충돌이 발생한다.
- 전체 버킷 대비 저장된 데이터의 개수를 `load factor = 엔트리 수 / 버킷수` 라고 한다. 로드팩터가 높을 수록 충돌가능성이 올라간다.

## 20.2 Collision Resolution
- 버킷수를 충분히 늘려서 충돌확률을 줄일수는 있지만 비효율적이고, 결국 충돌은 일어난다. 이것을 해결할 메카니즘이 필요하다.
### Separate chaining
![chaining](chaining.png)
- 모든 요소가 충돌한다면 o(n)의 시간복잡도를 가지지만 로트팩터를 확인하면서 크기를 관리함으로 실제로 한 버킷은 한두개의 엔트리만 가진다.
- 링크드 리스트 구조이기 때문에 포인터를 통해서 여러 곳에 데이터가 흩어져있고 캐싱에 좋지 않다.
  - 첫번째 요소를 버킷에 직접 저장하거나, 링크드리스트의 노드가 여러 항목을 저장하도록 해서 포인터 오버헤드를 줄이기도 한다.
### Open addressing
![insert](insert-3.png)
- 모든 엔트리를 하나의 연속된 배열에 저장하기 때문에 단순하고 빠르다. 단 해시 테이블의 모든 오퍼레이션을 복잡하게 만든다.
- 사용가능한 버킷을 찾는것을 probing 이라고 하고, 찾는 순서를 probe sequence 라고 한다.
- Separate chaining　과 비교하면 똑같이 노드의 리스트를 관리하지만, 노드의 링크를 포인터로 저장하는게 아니라 노드 차체를 버킷 자체에 저장하는 것만 다른다.
## 20.3 Hash Functions 계속..