# Hash Tables 요약
해시 테이블은, 키와 값의 페이어인 엔트리의 배열로 키를 통해서 값을 찾을 수 있는 자료구조이다. 이 자료구조의 핵심적인 기능은 엔트리 수가 아무리 많아도 상수시간 안에 값을 찾을 수 있다는 것이다.
배열의 크기가 정해져 있을때, 임의의 길이의 키를 제약없이 사용하기 위해서는, 배열의 크기로 이 키 값들을 접어야 한다.
이때 해시함수 (정해진 길이로 만드는)와 모듈로 연산이 사용된다. 해시 함수는 입력에 대해서 결정적이어야 하며, 잘 분산된 값이 나와야하고, 빨라야 한다.
이렇게 계산된 index 는 충돌할 수 있다.
이러한 충도을 해결하는 메카니즘으로는 체이닝(링크드리스트) 와 오픈 어드레싱이 있다.
오픈 어드레싱에서 충돌이 발생할 때 사용 가능한 버킷을 찾는 것을 프로빙이라고 하고, 버킷을 탐색하는 순서를 프로브 시퀸스라고 한다.

해시 테이블 구현에 앞서, 키로 사용되는 string 객체를 생성할때 미리 해시값을 생성해서 객체에 저장시켜둔다.
한계 로트팩터를 설정하고 그 로르팩터를 초과할 때 마다 테이블의 크기를 가변적으로 늘린다.
테이블의 capacity 가 늘어났을 때, index 의 계산의 결과값도 바뀜으로 크기를 늘릴 때는 새로운 capacity 로 index 를 계산하여 테이블을 채운다.
테이블에서 엔트리를 삭제할때 충돌이 있는 엔트리의 경우 프로스 시퀸스의 중간에 있는 엔트라가 삭제되면 그 뒤의 엔트리는 고아가 되버린다.
이를 해결하기 위해서 tombstone 이라는 특별한 엔트리를 사용한다.

string 의 key 비교는 빨라야 한다. char 값을 하나하나 비교하는 것은 느리다. String Interning 이라는 테크닉을 통해서,
string 오브젝트가 중복되지 않도록 하면, 단순하게 주소값을 비교하는걸로 string 의 동등성을 확인할 수 있다.
String Interning 에도 HashTable 을 사용하지만, 이때는 key 를 비교할때 char 값을 하나하나 비교하는 전용함수를 사용한다.
이렇게 함으로써 HashTable 의 일반적인 사용(함수, 객체등 언어 전반에서 사용되는)에서 key 값의 비교를 빠르게 수행할 수 있다. 

# 문단별 흥미로운 내용
- 해시테이블의 진정한 힘은, 키가 얼마나 많든 상수시간에 값을 얻을 수 있다는 점이다.
## 20.1 An Array of Buckets
- 26개의 변수만 가질수 있다고 하면, 26개의 버킷만 준비하면 된다. 키 벨류 값이 할당된 버킷도 있지만 그렇지 않은 버킷이 있더라도 메모리 소비는 심하지 않다. 
  인덱스를 찾기도 쉽다. 키를 알파벳으로 사용하면 키가 주어졌을 때 a 를 뺀 값으로 인덱스를 찾을 수 있다. 헤시테이블은 여기에 해시함수, 동적크기조절, 충돌해결을 추가하지만, 
  여전히 직접 인덱싱 할 수 있는 연속적인 버킷 배열이라는 것은 변하지 않는다.
- 변수이름(키)을 8글자 까지 허용하면, 키를 그대로 index 로 변환하면 295,148 petabyte 의 버킷을 준비해야 한다. 이것은 비현실 적임으로 작은 배열 요소의 범위로 큰 수의 범위를 fold 해야한다.  
  이때 modulo 연산을 사용하면, 배열의 크기보다 작은 수의 범위로 키를 fold 할 수 있다. 자연히 이경우 index 의 충돌이 발생한다.
- 전체 버킷 대비 저장된 데이터의 개수를 `load factor = 엔트리 수 / 버킷수` 라고 한다. 로드팩터가 높을 수록 충돌가능성이 올라간다.

## 20.2 Collision Resolution
- 버킷수를 충분히 늘려서 충돌확률을 줄일수는 있지만 비효율적이고, 결국 충돌은 일어난다. 이것을 해결할 메카니즘이 필요하다.
### Separate chaining
![chaining](chaining.png)
- 모든 요소가 충돌한다면 o(n)의 시간복잡도를 가지지만 로트팩터를 확인하면서 크기를 관리함으로 실제로 한 버킷은 한두개의 엔트리만 가진다.
- 링크드 리스트 구조이기 때문에 포인터를 통해서 여러 곳에 데이터가 흩어져있고 캐싱에 좋지 않다.
  - 첫번째 요소를 버킷에 직접 저장하거나, 링크드리스트의 노드가 여러 항목을 저장하도록 해서 포인터 오버헤드를 줄이기도 한다.
### Open addressing
![insert](insert-3.png)
- 모든 엔트리를 하나의 연속된 배열에 저장하기 때문에 단순하고 빠르다. 단 해시 테이블의 모든 오퍼레이션을 복잡하게 만든다.
- 사용가능한 버킷을 찾는것을 probing 이라고 하고, 찾는 순서를 probe sequence 라고 한다.
- Separate chaining　과 비교하면 똑같이 노드의 리스트를 관리하지만, 노드의 링크를 포인터로 저장하는게 아니라 노드 차체를 버킷 자체에 저장하는 것만 다른다.

## 20.3 Hash Functions
- 해시함수: 임이의 길이의 스트링을 정해진 길이의 정수(정수가 아니어도 된다)로 바꾸는 함수. 다음과 같은 조건을 만족시켜야 한다.
  - 결정적이어야 한다: 같은 입력에 대해서 같은 출력을 내야 한다.
  - 균일해야 한다: 해시 테이블에서 클러스터링(군집화)에 의한 충돌을 최소화 하기 위해서 균일하게 분포된 값을 출력해야 한다.
  - 빨라야한다. 
  ※ 보안이 중요한 경우에는, 단방향성 그리고 원본 데이터를 노출 시키면 안된다.

## 20.4 Building a Hash Table
- 모든 문자열을 살펴서 캐싱을 하는데, 이것을 매번 계산하는건 시간이 걸리니 자료구조에 저정해 둔다.(캐싱한다).
- adjustCapacity 로 hashTable 를 확장할때 realloc 을 사용해서 copy 할 수는 없다. 왜냐하면 adjustCapacity 후에 table 에 capacity 가 바뀜으로, 
  이전에 할당된 index 가 모두 무용지물이 된다.
```c
bool tableGet(Table* table, ObjString* key, Value* value) {
  if (table->count == 0) return false;

  Entry* entry = findEntry(table->entries, table->capacity, key);
  if (entry->key == NULL) return false;

  *value = entry->value;  // value 역참조, 즉 value 의 값들에, entry->value 의 값들이 복사된다. value 는 obj 제외하고는 전부 값타입의 필드를 가지고 있다.
  return true;
}
```
- adjustCapacity 에서 tombstones 는 카피되지 않는다.(probe sequences 를 다시 만드는데 tombstones 를 넣을 필요가 없다.) 
- tombstones 어프로치는 lookup 에서 패널티를 가지지만, 다시 사용할 공간을 제공하는걸로 재조정의 비용을 피할수 있다. 결과적으로 tombstones 접근은 tombstones 를 남가지 않고 엔트리를 실제로 삭제하는 접근보다 전체적으로 빠르다.  
## 20.5 String Interning
- findEntry 에서 key 를 비교할때 == 연산을 사용하지만, 이 연산은 정확하게 메모리 위치까지 일치할때만 true 를 돌려준다. char 를 하나하나 비교하는 방법도 있지만 느림으로 
  string interning 이라는 테크닉을 사용한다. string interning 은 string 의 중복을 허용하지 않는 것이다. 이 테스닉으로 각각의 스트링은 메모리에 한곳에만 존재하게 되고,
  값 비교를 아주 사소한 문제로 만들어 버린다. 만약 두 string 이 같다면, 이 두 string 은 같은 주소를 가지고 있을것 이기 때문에 주소만 확인하면 된다.
- string interning 에 hashTable 을 사용한다. findEntry 는 위와 같은 문제가 있음으로 string interning 을 위해 hashTable 을 사용할 때는 tableFindString 이라는 전용 함수를 구현해 사용한다.
  - key 는 ObjString* 이 아니라 char* 다.
  - key 비교에서 실제 문자열을 비교한다. memcmp(entry->key->chars, chars, length) 이는 vm이 string 에 대해서 컨텐츠 비교를 하는 유일한 장소이다.
- string interning 을 함으로 string 을 생성할 때 약간의 오버헤드를 통해서, string 동등성 연산이 훨씬 빨라졌다. 
  Lox 같은 동적 타입 언어에서 메서드나 객체를 전부 이름으로 찾기 때문에 string 동등성 연산이 느린것은 아주 치명적이다.

## CHALLENGES
- key 의 동등성을 어떻게 비교할 것인가.
- 자바는 체이닝 → 충돌이 많아저도 비용증가가 일관적이다.(프로빙이 더 비쌈), 파이썬은 오픈어드레싱 → 캐시효율에 좋다.     
  하드웨어에 따라 해시함수도 달라짐, 예) CPU, GPU 에서 빠른 해시 함수가 따로있다.
- 엔트리 개수별 성능을 추척한다. 
