# Compiling Expression 요약

# 문단별 흥미로운 내용  
 ※ "primes the pump": 마중물을 붓다
## 17.1 Single-Pass Compilation
- 컴파일러는 사용자의 소스코드를 파싱해서 그 의미를 이해하고, 그를 바탕으로 바탕으로 동일한 의미를 가지는 저수준 명령어를 생성한다.
많은 언어에서는 이 두 역할을 별도의 pass 로 나누지만 clox 에서는 단순하기 위해서 이 두 pass 를 하나로 합친다.
- 이러한 Single-Pass compiler 는 모든 언어에서 잘 동작하는 것은 아니다.
구문 조각을 이해하는데 컨택스트가 많이 필요하지 않도록 설계된 언어만 잘 동작한다. lox는 그렇게 설계되었다.
- clox 에서 compiler 는 토큰을 소비하고 청크에 상수를 추가하면서 바이트 코드를 생성한다.
- 이 장에서는 파싱과 코드생성을 구축한 후에 Pratt의 테크닉을 사용한 코드를 통해서, lox 의 특정 문법을 파싱하고 올바른 바이트 코드를 출력하도록 연결한다.

## 17.2 Parsing Tokens
- advance(): 루프를 돌면서 스캐너의 sanToken() 을 실행시켜서 토큰을 Parser에 셋팅한다.
### 17.2.1 Handling syntax errors
- panicMode flag 가 설정되면 동기화가 가능한 지점까지 error 더이상 에러 리포트를 하지 않는다. 록스에서 동기화가 가능한 지점은 문장 경계이다.

## 17.3 Emitting Bytecode
- emitByte(): op-code 나 operand 를 compilingChunk 에 쓴다. 
  ※:when we start compiling user-defined functions, the notion of “current chunk” gets more complicated. To avoid having to go back and change a lot of code, I encapsulate that logic in the currentChunk() function.

## 17.4 Parsing Prefix Expressions
- 파싱과 코드생성 유틸리티 펑션을 조립했음으로 남은 부분은 두 부분을 연결하는 것 이다.
![mystery](mystery.png)
### 17.4.1 Parser for tokens
- 각각의 토큰을 서로 다른 표현식으로 매핑한다. 각각의 표현식을 적절한 바이트코드로 출력하는 함수를 만든다. 이 함수들의 포인터를 배열에 저장한다.  
이배열의 인덱스는 TypeToken 에넘 값 이고, 각 인덱스에 상응하는 함수는 토큰타입의 표현식을 컴파일 하는 함수다.
  - 먼저 TOKEN_NUMBER 에 상응하는 number() 함수를 작성한다.
### 17.4.2 Parentheses for grouping
- 모든 표현식이 단 하나의 토큰으로 이루어져 있으면 매우 편하겠지만 그렇지는않다. 그러나 많은 표현식은 특정 토큰으로 시작하고 이러한 표현식을 접두 표현식(prefix expression) 이라고 부른다.  
예를들어 "(" 토큰을 확인한다면 parenthesized grouping expression 인지도 살펴봐야 한다는걸 알 수 있다.
※ 프랫 파서는 하향식 재귀 파서가 아니지만, 문법 자체가 재귀적이기 때문에 프랫 파서도 재귀적이다.
- 백엔드 관점에서 보면 그룹 표현식은 아무것도 아니다. 그것의 기능은 더 높은 우선순위가 요구되는 곳에 너 낮은 우선순위의 표현식을 넣을 수 있게 해주는 구문적 역할 밖에 없다.
그룹 표현식은 런타임에서의 의미가 없으며 바이트코드를 생성하지도 않는다. 괄호 안의 표현식은 expression() 의 호출에 의해서 바이트 코드를 생성한다.
```c
static void grouping() {
  expression();
  consume(TOKEN_RIGHT_PAREN, "Expect ')' after expression.");
}
```
### 17.4.3 Unary negation (단항 부정)