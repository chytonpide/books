# Compiling Expression 요약

# 문단별 흥미로운 내용  
 ※ "primes the pump": 마중물을 붓다
## 17.1 Single-Pass Compilation
- 컴파일러는 사용자의 소스코드를 파싱해서 그 의미를 이해하고, 그를 바탕으로 바탕으로 동일한 의미를 가지는 저수준 명령어를 생성한다.
많은 언어에서는 이 두 역할을 별도의 pass 로 나누지만 clox 에서는 단순하기 위해서 이 두 pass 를 하나로 합친다.
- 이러한 Single-Pass compiler 는 모든 언어에서 잘 동작하는 것은 아니다.
구문 조각을 이해하는데 컨택스트가 많이 필요하지 않도록 설계된 언어만 잘 동작한다. lox는 그렇게 설계되었다.
- clox 에서 compiler 는 토큰을 소비하고 청크에 상수를 추가하면서 바이트 코드를 생성한다.
- 이 장에서는 파싱과 코드생성을 구축한 후에 Pratt의 테크닉을 사용한 코드를 통해서, lox 의 특정 문법을 파싱하고 올바른 바이트 코드를 출력하도록 연결한다.

## 17.2 Parsing Tokens
- advance(): 루프를 돌면서 스캐너의 sanToken() 을 실행시켜서 토큰을 Parser에 셋팅한다.
### 17.2.1 Handling syntax errors
- panicMode flag 가 설정되면 동기화가 가능한 지점까지 error 더이상 에러 리포트를 하지 않는다. 록스에서 동기화가 가능한 지점은 문장 경계이다.

## 17.3 Emitting Bytecode
- emitByte(): op-code 나 operand 를 compilingChunk 에 쓴다. 
  ※:when we start compiling user-defined functions, the notion of “current chunk” gets more complicated. To avoid having to go back and change a lot of code, I encapsulate that logic in the currentChunk() function.

## 17.4 Parsing Prefix Expressions
- 파싱과 코드생성 유틸리티 펑션을 조립했음으로 남은 부분은 두 부분을 연결하는 것 이다.
![mystery](mystery.png)
### 17.4.1 Parser for tokens
- 각각의 토큰을 서로 다른 표현식으로 매핑한다. 각각의 표현식을 적절한 바이트코드로 출력하는 함수를 만든다. 이 함수들의 포인터를 배열에 저장한다.  
이배열의 인덱스는 TypeToken 에넘 값 이고, 각 인덱스에 상응하는 함수는 토큰타입의 표현식을 컴파일 하는 함수다.
  - 먼저 TOKEN_NUMBER 에 상응하는 number() 함수를 작성한다.
### 17.4.2 Parentheses for grouping
- 모든 표현식이 단 하나의 토큰으로 이루어져 있으면 매우 편하겠지만 그렇지는않다. 그러나 많은 표현식은 특정 토큰으로 시작하고 이러한 표현식을 접두 표현식(prefix expression) 이라고 부른다.  
예를들어 "(" 토큰을 확인한다면 parenthesized grouping expression 인지도 살펴봐야 한다는걸 알 수 있다.
※ 프랫 파서는 하향식 재귀 파서가 아니지만, 문법 자체가 재귀적이기 때문에 프랫 파서도 재귀적이다.
- 백엔드 관점에서 보면 그룹 표현식은 아무것도 아니다. 그것의 기능은 더 높은 우선순위가 요구되는 곳에 너 낮은 우선순위의 표현식을 넣을 수 있게 해주는 구문적 역할 밖에 없다.
그룹 표현식은 런타임에서의 의미가 없으며 바이트코드를 생성하지도 않는다. 괄호 안의 표현식은 expression() 의 호출에 의해서 바이트 코드를 생성한다.
```c
static void grouping() {
  expression();
  consume(TOKEN_RIGHT_PAREN, "Expect ')' after expression.");
}
```
### 17.4.3 Unary negation (단항 부정)
- operand 를 먼저 컴파일 한 후에 OP_NEGATE 를 출력하는데 이는 스택을 사용한 실제 실행이 반영된 순서이다. 컴파일러는 소스코드에서 나타난대로 파싱을 한 후에, 실제로 실행되는 순서로 그것을 조정한다. 
- `-a.b + c;` 를 unary() 에서 처리한다고 할때, -는 `a.b` 에만 적용되어야 하지만 `expression` 함수는 은 `a.b + c` 를 처리할 것이다. `a.b` 만 처리하도록 하기 위해서는 precedence 가 필요하다.
```c
static void unary() {
  TokenType operatorType = parser.previous.type;

  // Compile the operand.
  expression();

  // Emit the operator instruction.
  switch (operatorType) {
    case TOKEN_MINUS: emitByte(OP_NEGATE); break;
    default: return; // Unreachable.
  }
}

```
- jox 에서는 허용하는 가장 낮은 수선순위의 파싱 메서드를 호출함으로써, 각 우선순위별로 정의된 파싱 메서드는, 자신보다 더 높은 우선순위를 가진 식들도 함께 파싱하게 되어 있어서, 결국 나머지 우선순위 테이블 전체를 파싱할 수 있었다.
- clox 에서의 메서드는 다르다. 각각의 메서드는 정확하게 하나의 타입의 표현식을 다룬다. (높은 우선순위의 메서드를 호출하지 않는다.) 대신 clox 에서는 `parsePrecedence` 함수를 사용한다.  
  이 함수는 주어진 우선순위 수준 이상에 해당하는 모든 표현식을 파싱한다.
  - clox 에서는 Precedence 에넘을 사용해서 우선순위를 명시적으로 표현한다.
  - expression(); 이 아닌 parsePrecedence(PREC_UNARY); 를 호출함으로써 + 이항식을 파싱하지 않는다.

