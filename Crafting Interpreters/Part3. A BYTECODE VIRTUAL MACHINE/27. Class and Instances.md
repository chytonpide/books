# Class and Instances 요약

클래스와 인스턴스 기능을 구현한다. 
클래스의 런타임 표현 ObjClass 먼저 구현한다.
클래스 선언문장의 컴파일을 구현한다. 클래스 이름을 선언, OP_CLASS 옵코드 에밋, 클래스 이름 정의 순으로 컴파일 한다.
런타임에서는 OP_CLASS 를 인터프리팅 하면서 ObjClass 를 생성한다.

인스턴스 기능을 구현한다. 클래스의 중요한 두가지 목적은 다음과 같다.
- 어떻게 새로운 인스턴스를 생성하는지. 
- 클래스의 모든 인스턴스가 어떻게 행동하는지 정의하는 메서드를 포함하고 있다.
여기서는 클래스를 통해서 새로운 인스턴스를 생성하는 방법을 먼저 구현한다.
인스턴스의 런타임 표현 ObjInstance 를 먼저 구현한다.
런타임에서 인스턴스의 초기화는 ObjClass 를 call 하는것으로 이루어진다.

인스턴스가 상태를 가지도록 한다. Get Set 기능을 구현한다. 
dot 을 포함한 Get Set 표현식은 중위식으로 취급한다.
canAssign 플래그로 OP_SET_PROPERTY 와 OP_GET_PROPERTY 를 구분해서 에밋한다.
OP_SET_PROPERTY 와 OP_GET_PROPERTY 를 인터프리팅 할때, 중위식 컴파일에 의해서 인스턴스가 이미 스택에 설정되어 있다. 
이들 op_code 는 컴파일 chunk.constants 에 설정된 프러퍼티 이름을 참조한다.

반쪽짜리 클래스이지만 클래스와 인스턴스, 그리고 인스턴스의 필드를 통해서 유저는 자유롭게 더 큰 단위로 데이터를 집약 할 수 있다.

# 문단별 흥미로운 내용

# 27.1 Class Objects

# 27.2 Class Declarations
- 클래스 선언을 컴파일 할때, 이름을 chunk 의 constants 에 저장하고, 이름과 함께 OP_CLASS 를 에밋하고, 이름과 함께 OP_DEFINE_GLOBAL 를 에밋한다.(런타임에 이름을 찾을 수 있도록)
- 클래스 선언을 인터프리팅 할때, OP_CLASS 의 인터프리팅에 의해서 ObjClass 가 생성되어 stack 에 올라가 있다. 이어서 OP_DEFINE_GLOBAL 의 인터프리팅에 의해 vm.globals 에 ObjClass 가 올라간다.

## 27.3 Instances of Classes
- 유저의 관점에서 정의한 클래스는 서로 다른 타입이지만, VM 의 입장에서는 ObjClass 타입이 다른 값이다. 마찬가지로 유저 프로그램의 각각의 클래스의 인스턴스들도 ObjInstance 로 같은 타입의 다른 값들이다.  

## 27.4 Get and Set Expressions
- setter 는 할당된 값이 결과인 표현식 임으로 그 값이 스택에 남아야 한다. 
```
class Toast {}
var toast = Toast();
print toast.jam = "grape"; // Prints "grape".
```
- 현재까지 구현한 기능은 객체가 데이터의 가방이 되는것으로 절차적 언어에서 사용되는 C 의 struct 와 비슷하다. 하지만 표현력 면에서는 큰 진전으로 사용자가 데이터를 더 큰 단위로 집약할 수 있게 해준다.

## Challenges
- 1. Lox 에서는 잘못된 필드에 접근하면 그대로 종료된다. 다른 언어에서는 어떤가?
  - javascript 에서는 undefined 를 되돌려 준다. 체크는 할 수 있도록 해야한다.
    - null은 사용자가 프로그램 내에서 원하는 의미를 부여할 수 있는 “애플리케이션 수준”의 부재 값 
    - undefined는 정의되지 않은 필드에 접근하는 것과 같은 내장 언어 의미론에서 반환되는 “시스템 수준”의 부재 값
- 2. 필드이름을 문자열 값으로 생성하고 그것을 사용할수 있도록 하는게 좋을까? 이 언어기능을 구현하라
  - 해답: 메타프로그래밍과 일반 프로그래밍을 명시적으로 구분하는게 좋다. (자비의 리플렉션 패키지처럼 별도 기능으로 제공한다.)
- 3. lox 에서는 instance 의 field 를 완전히 제거할 수 없다. 다른언어는 어떤가? 구현 전략을 선택하라
  - javascript 에서는 delete 를 사용할 수 있다.
- 4. 동적 타입언어는 런타임에 이름으로 엑세스 되기 때문에 정적 타입 언어보다 느리다. 이를 최적화 하기 위해서 어떻게 정교한 구현을 할 수 있을까?
  - 해답: SELF 라는 언어는 동적으로 컴파일을 실행해서 복수개의 클래스의 버전을 만들어서 사용한다. 이렇게 타입을 정적인 것 처럼 만들어서 필드 엑세스를 정적 타입 언어처럼 효율적으로 처리할 수 있다.   