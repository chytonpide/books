

# 문단별 흥미로운 내용

## An Instruction Execution Machine
### Executing instructions
- IP - instruction pointer, x86 이나 JVM 에서는 이것을 PC - program counter 라고 부른다.
- vm 이 동작하는 동안 ip 는 앞으로 실행할 instruction 을 가르킨다.
- bytecode dispatch : opcode 를 확인 한 후에 instruction 의 시멘틱을 구현한 코드를 얻을 필요가 있다. 이 프로세스를 인스트럭션의 디코딩 또는 디스페칭 이라고 부른다.
```c
static InterpretResult run() {
#define READ_BYTE() (*vm.ip++)
#define READ_CONSTANT() (vm.chunk->constants.values[READ_BYTE()])

  for (;;) {
    uint8_t instruction;
    switch (instruction = READ_BYTE()) {
      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        printValue(constant);
        printf("\n");
        break;
      }
      case OP_RETURN: {
        return INTERPRET_OK;
      }
    }
  }

#undef READ_BYTE
#undef READ_CONSTANT
}
```
### Executing tracing
### 맺음
- run() 함수의 for-loop 로 감싸진 switch 문은 VM 두가지 핵심 구성요소중 하나다. 이 코드를 통해 명령어들을 바로 실행 할 수 있고, 단순하고 빠르다.  
jlox 에서 AST 를 탐색 하기 위해 사용했던 비지터 패턴과 비교해 보면, 그것이 훨씬 복잡하고 오버헤드가 많았다는 것을 알 수 있다.

## A Value Stack Manipulator
```
fun echo(n) {
  print n;
  return n;
}

print echo(echo(1) + echo(2)) + echo(echo(4) + echo(5));
```
- 위 코드를 실행 한다고 할 때 변수의 유지방법
  - jlox: JAVA 의 지역변수 - tree-walk interpreter 는 각 노드가 계산되는 동안 독립적인 JAVA 콜 스택 프레임을 만들고(메서드 호출 될 때마다 독립된 컨택스트를 가진다.) 원하는 만큼 지역변수를 가질 수 있다.
  - clox: 스택 - run 함수 (인터프리터 부분) 는 재귀적으로 동작하지 않는다. jlox 에서의 표현의 트리는, clox 에서는 평탄화된 instruction 의 시리즈이다. 추적해야 하는 값이 아래처럼 스택과 유사한 행동을 하기 때문에 스택을 사용한다.  
![bars-stacked](bars-stacked.png)

### The VM's stack
- I remember it like this: stackTop points to where the next value to be pushed will go.