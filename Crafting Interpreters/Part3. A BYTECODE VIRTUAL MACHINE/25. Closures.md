# Closures 요약


# 문단별 흥미로운 내용
- jlox 에서는 모든 지역변수를 동적으로 할당 하는것으로 클로저를 단순하게 구현할 수 있다. clox 에서는 훨씬 빠른 stack 에 지역변수를 저장하는데 거의 사용되지 않는 클로저 구현을 위해서 이것을 포기하는 것은 비 합리적이다.
  clox 에서는 두가지 구현 전략을 사용한다. 클로저로 사용되지 않는 지역변수는 스택에 저장하고, 클로저에 의해서 캡쳐되는 지역변수는 힙으로 올린다.

## 25.1 Closure Objects
- 현재 VM 은 런타임에서 ObjFunction 을 통해서 함수를 표현한다. 이 객체는 컴파일 타임에 생성된다. VM 은 상수 테이블에서 그것을 읽어와서 이름과 바인드한다. 함수를 생성하는 오퍼레이션은 없다.
  - a function declaration in Lox is a kind of literal—a piece of syntax that defines a constant value of a built-in type.
- 아래 코드에서 makeClosure 함수는 런타임에 closure 함수를 만든다. 각각의 클로저 함수가 제대로 동작하려면 지역변수를 캡쳐하는 클로저를 위한 런타임 표현이 필요한다. 즉 기존의 표현으로는 불충분한다. 
```
fun makeClosure(value) {
  fun closure() {
    print value;
  }
  return closure;
}

var doughnut = makeClosure("doughnut");
var bagel = makeClosure("bagel");
doughnut();
bagel();
```
- 새로운 표현은 ObjClosure다. 런타임에서 함수 선언이 실행될 때, ObjFunction 를 ObjClosure 로 감싼다. ObjClosure 는 함수 그 자체와 함께 클로즈 오버되는 변수의 런타임 상태를 가진다.
### 25.1.1 Compiling to closure objects
- OP_CLOSURE 를 어떻게 emit 하는 컴파일 과정에 대해 알아보자. OP_CLOSURE 는 언제 vm 이 ObjFunction 을 감싸는 ObjClosure 를 언제 만들어야 하는지 말해준다.
### 25.1.2 Interpreting function declarations
- OP_CLOSURE 를 인터프리팅 할때, constant 에 존재하는 ObjFunction 을 읽어서, ObjClosure 로 감싼후 이것을 stack 에 올린다. ObjFunction 은 이제 constant 테이블들에만 존재하고,
  호출에 있어서도, vm 은 이제 ObjFunction 을 직접 호출하지 않고 ObjClosure 로 랩핑된 것을 호출 한다. 
- 컴파일러는 이제 매 함수 선언마다 VM 에게 클로저를 만들라고 말하는 코드를 생성한다. (the compiler now generates code telling the VM to create a closure for each function declaration.)
  
## 25.2 Upvalues
- closed-over 된 지역변수가 항상 stack 에 존재 한다면, 함수의 윈도우 이전의 스택 슬롯에 접근할 수 있도록 하면 되겠지만, 함수가 정의되는 곳 밖의 지역변수를 closed-over 하는 경우도 있다.
  이 지역변수는 stack 에 없을 수도 있다.
  또 다른 방법은 지역변수를 선언할 때 힙에 둘수 있지만 clox 는 싱글패스 컴파일러로 이렇게 할 수 없다. 아래 코드처럼 변수가 변경되는 것을 감지할 수 없기 때문이다.
  (클로즈 오버된 x 는 2 여야 한다.)
```
fun outer() {
  var x = 1;    // (1)
  x = 2;        // (2)
  fun inner() { // (3)
    print x;
  }
  inner();
}
```
- 따리서 clox 에서는 upvalue 라는 간접참조 수준을 사용한다. upvalue 는 지역변수를 감싸는 함수안에서의 지역변수를 참조한다.
  모든 클로저는, 각 클로저가 사용하는 주변 지역 변수에 대해서 upvalues 배열을 관리한다.
  함수 선언이 처음 실행되어서 closure 를 만들때, vm 은 upvalues 의 배열을 만들고 클로저가 필요로 하는 주변 지역변수를 캡쳐하도록 그것을 연결한다.
### 25.2.1 Compiling upvalues
- Lox 는 지역변수는 렉시컬한 스코프를 가짐으로 컴파일 타임에 클로저가 얼마나 많은 업벨류를 필요로 하는지, 어떤 것들을 캡쳐하는지 어떤 스택 슬롯이 이 변수들을 포함하는지 알 수 있다.
- 현재 컴파일러는 identifier 를 리졸브 할때, 현재 스코프에 없으면 글로벌 스코프를 찾는다. 그것을 감싸는 함수의 로컬 스코프를 고려하도록 컴파일러를 수정해야 한다.
- 컴파일러는 identifier 를 리졸브 할 때, 감싸는 함수의 지역변수의 upvalue index 를 찾아서 OP_GET_UPVALUE, OP_SET_UPVALUE 과 함께 chunk 에 기록한다.
 - Compiler.locals 와 CallFrame.slots 의 인덱스는 연동된다.
 - Compiler.upvalues 와 ObjClosure.upvalues 는 연동된다. (나중에 구현) 
※ upvalueCount 는 Function, upvalues 배열 자체는 Compiler 에 보존한다. upvalueCount 는 vm 에서 다시 사용하나? → 맞다.  

### 25.2.2 Flattening upvalues
- 아래 클로저가 제대로 동작하려면, stack 에서 이미 팝된 closed over 된 변수를 찾을 수 있어야 하고(outer()호출 후 stack 에서 이 함수 스코프의 지역변수는 모두 pop 되기 때문에), 
  바로 위의 감싸는 함수보다 위에서 정의된 지역변수를 리졸브 할 수 있어야 한다.
```
return from outer
create inner closure
value

```
```
fun outer() {
  var x = "value";
  fun middle() {
    fun inner() {
      print x;
    }

    print "create inner closure";
    return inner;
  }

  print "return from outer";
  return middle;
}

var mid = outer();
var in = mid();
in();
```
- 애초에 upvalues 는 스택을 벗어난 변수를 추적하도록 디자인 되어있다. 이 문제를 해결하는 방법은 각 함수가 다음 함수가 가저갈 수 있도록 위에서 선언된 변수를 캡쳐해서 전달 하는 것이다. 
  이렇게 하면 중첩된 함수가 실행되며 클로즈드 오버된 변수에 엑세스할때, 자신을 감싸고 있는 함수의 ObjClosure 에서 upvalue 를 통해서 그보다 위의 함수에서 선언된 지역변수를 사용할 수 있게 된다.
  이렇게 하려면 `resolveUpvalue` 를 재귀적으로 만들어야 한다.
  - Most recursive functions either do all their work before the recursive call (pre-order traversal)
  - or they do all the work after the recursive call (post-order traversal)
![linked-upvalues](linked-upvalues.png)
- resolveUpvalue 이 재귀적으로 캡쳐한 변수를 찾을때 isLocal 를 기록한다. isLocal 이 true 인 경우는 바로 위의 함수 스코프에서 지역변수를 찾았을 때다. 이는 OP_CLOSURE 를 에밋 할때,
  argument 로 같이 제공되어서 vm 에게 어디서 캡쳐된 변수를 찾아야 하는지 정보를 제공한다.
- 이제 컴파일러는 매 함수 정의마다 OP_CLOSURE 와 런타임에 캡쳐해야 하는 upvalue 를 위한 인수를 emit 한다.

## 25.3 Upvalue Objects
- upvalue 는 스택에 더 이상 살지 않는 클로즈드 오버된 변수를 관리해야 한다. 이는 어느정도 동적할당을 필요로 한다는 것이고, 이것을 가장 쉽게 하는 방법은 이미 만들어놓은 객체 시스템을 이용하는 것이다.
  location 는 값 자체가 아니라 변수에 대한 포인터 이다. 
```
typedef struct ObjUpvalue {
  Obj obj;
  Value* location;
} ObjUpvalue;
```
### 25.3.1 Upvalues in closures
- compile 타임 → Compiler.upvalues (Upvalue), run 타임 → ObjClosure.upvalues (ObjUpvalue**)  
```
typedef struct {
  Obj obj;
  ObjFunction* function;
  ObjUpvalue** upvalues; // 동적 배열에 대한 포인  
  int upvalueCount;
} ObjClosure;
```
```
case OP_CLOSURE: {
  ObjFunction* function = AS_FUNCTION(READ_CONSTANT());
  ObjClosure* closure = newClosure(function);
  push(OBJ_VAL(closure));
  for (int i = 0; i < closure->upvalueCount; i++) {
    uint8_t isLocal = READ_BYTE();
    uint8_t index = READ_BYTE();
    if (isLocal) {
      closure->upvalues[i] = captureUpvalue(frame->slots + index); // isLocal 인경우 감싸는 함수의 stack 의 위치로 ObjUpvalue 를 만든다.
    } else {
      closure->upvalues[i] = frame->closure->upvalues[index]; // 모든 실행은 콜프래임 안에서 이루어지고 상위 closure의 upvalue 에서 값을 찾아오는건 타당하다.
    }
  }
  break;
}
```
- OP_CLOSURE 를 처리하면서, compile 타임에 캡쳐된 upvalue 를 CallFrame.ObjClosure.ObjUpvalue 로 옮긴다. 
  이후 OP_GET_UPVALUE 는 CallFrame.ObjClosure.ObjUpvalue 에서 upvalue 를 찾아 stack 에 올린다.
- compiler 에서 변수를 컴파일한 결과가 (OP_GET_LOCAL, OP_SET_LOCAL), (OP_SET_UPVALUE, OP_GET_UPVALUE), (OP_GET_GLOBAL, OP_SET_GLOBAL) 이 된다. 
  - resolve 는 compile 타임에 이루어진다. compiler 는 변수 이름을 local 에 저장하고 있다가, resolve 한뒤 OP_GET_LOCAL 과 slot 인덱스를 돌려준다.
    upvalue 의 경우도 resolve 는 컴파일 타임에 resolveUpvalue 를 통해 이루어진다. 
    
## 25.4 Closed Upvalues
- CallFrame 안에 closure 가 있기 때문에, 다음과 같이 CallFrame 이 종료되면 closure 에 접근할 방법이 없다. 이 문제를 해겨하기 위해서 스코프가 끝나도 힙에 남겨야할 upvalue 들을 추적할 수 있게 해야 한다.
  클로저는 변수를 캡쳐해야 한다. 캡쳐된 변수를 조회할 수 있도록 ObjUpvalue 는 링크드 리스트 형태로 vm 에서 관리 되어야 한다. 
```
fun outer() {
  var x = "outside";
  fun inner() {
    print x;
  }

  return inner;
}

var closure = outer();
closure();
```
### 25.4.1 Values and variables
- Lox 를 포함한 거의 모든 언어의 클로저는 값이 아니 변수를 캡쳐한다. 값이 살고 있는 장소를 캡쳐하는거라고 생각할 수 있다.
### 25.4.2 Closing upvalues
- stack 에 여전히 남이있는 upvalue 를 "open upvalue" 라고 부르고, 힙으로 이동된 upvalue 를 closed upvalue 라고 부른다. 클로저의 구현에 있어서 다음과 같은 두가지 질문에 답해야 한다.
  - 둘러쌓인 변수는 힙의 어디에 저장되어야 하는가? → 이미 구현한 객체 시스템을 활용하여 ObjUpvalue 를 정의해 사용한다.  
  - 언제 upvalue 를 닫아야 하는가? → 로컬 변수를 벗어나는 시점에 open upvalue 를 만들어야 한다. 현재의 컴파일러는 지역변수가 캡쳐되었다는 걸 알 수 없음으로, Local 에 isCaptured 플래그를 추가한다.  
### 25.4.3 Tracking open upvalues
- 다른 클로저가 캡쳐된 변수를 변경하더라도 그 변수가 공유되도록 해야한다. 이를 위해서 먼저 VM 이 모든 open upvalue 들의 리스트를 관리하도록 해야 한다.
### 25.4.4 Closing upvalue at runtime .. 계속