# Closures 요약
closure 를 구현한다. jlox 에서 모든 환경을 힙에 두었지만 clox 에서는 closure 와 그것이 아닌 것들의 패턴별로 구현을 한다.  
먼저 closure 를 위한 인프라 스트럭쳐를 구현한다. ObjClosure 라는 클로저의 표현을 만든 후 이 표현이 ObjFunction 을 멤버로 가지도록 하고,
compiler 와 vm 이 이 표현을 사용하도록 한다.  
기존의 ObjFunction 은 리터럴 처럼 컴파일 되고, 인터프리팅 되었지만, 이제는 컴파일러는 function 이 정의될 때 OP_CLOSURE 라는 오퍼레이션을 사용해서 언제 vm 에서 ObjClosure 가 만들어져야 하는지 지시한다.  
(compiler 는 여전히 ObjFunction 을 만들지만, ObjClosure 는 vm 에서 생성된다. object 시스템을 사용하지만 성격이 다르다.)

upvalue 는 어떤 함수를 감싸는 스코프의 로컬 변수를 표현한다.  
compiler 가 사용하는 `Upvalue` 표현을 정의한다.  
compiler 는 locals 를 가지는 것 처럼, upvalues 를 멤버로 가지고 컴파일 결과, 이 필드에 upvalue 의 정보, 즉 슬롯에서의 index, 지역변수인지를 설정한다.
이 정보가 OP_GET_UPVALUE, OP_SET_UPVALUE 의 인수로 같이 emit 된다.
클로저의 요건에서 더 상위의 스코프에서 클로즈 오버된 지역변수에도 접근할 수 있어야 함으로 upvalue 의 리졸브는 재귀적으로 이루어져야 한다.
  
런타임에서의 표현인 `ObjUpvalue` 를 정의한다. 함수가 일단 정의되고, vm 은 OP_CLOSURE 를 인터프리팅 할때, 
closure 를 생성한후 맴버인 upvalue 의 배열을 초기화 하고, compiler 가 OP_CLOSURE 함께 emit 한 upvalue 들을 활용해서 이를 초기화 한다.  
(upvalue 들은 복수번 연속적으로 emit 된다.)
이제 OP_GET_UPVALUE, OP_SET_UPVALUE 를 인터프리팅 할때, closure 의 upvalues 필드를 인수로 넘어온 slot 숫자로 엑세스 할 수 있다.  
  
스택에서 closed over 된 지역변수가 사라졌을때도, 다른 타이밍이 클로저가 포함된 함수를 호출했을 때 엑세스 할 수 있어야 한다.  
클로저는 값을 클로즈드 오버 하는것이 아니라, 위치를 클로즈드 오버한다.  
스택에 여전히 살아 있는 upvalue 를 `open upvalue` 라고 부르고 힘으로 이동된 upvalue 를 `closed upvalue` 라고 부른다.  
두가지 질문에 답을 할 필요가 있다. 클로즈드 오버 된 변수를 어디에 저장할 것인가?, 언제 upvalue 를 클로즈 할 것 인가?  
첫번째 질문의 답변은 ObjUpvalue 자체가 object 시스템을 사용해서 힙에 존재함으로 ObjUpvalue 에 closed 필드를 추가한 후에 여기에 값을 저장하는것이다.  
둔번째 질문의 답변은 스코프를 종료할 때다. 컴파일러가 scope 를 종료할때 OP_CLOSE_UPVALUE 를 에밋하고 이것을 vm 이 인터프리팅 할때 upvalue 를 close 하게 하는것이다.   
(vm 에서 return 을 인터프리팅 할때도 close 하도록 한다.)  

compiler 가 어떤 지역변수에 대해서 OP_CLOSE_UPVALUE 를 emit 해야할지 알수 없음으로, 컴파일러의 Local 지역변수 표현에 isCaptured 라는 필드를 추가하고,
upvalue 를 리졸브 할때 isCaptured 가 설정되도록 한다. (OP_CLOSE_UPVALUE 는 필요한 만큼 복수개 emit 된다.)    
vm 은 openUpvalues 필드를 가지고 `open upvalue` 를 추적한다. (이 필드는 참조다.)  
vm 은 OP_CLOSE_UPVALUE 나 OP_RETURN 을 인터프리팅 할때, openUpvalues 를 통해서 각각의 `ObjUpvalue` 접근 한 후, `closed` 필드에 값을 설정하고,  
접근할 때 사용하는 `location` 필드가 이 값을 가르키도록 한다.  
  

# 문단별 흥미로운 내용
- jlox 에서는 모든 지역변수를 동적으로 할당 하는것으로 클로저를 단순하게 구현할 수 있다. clox 에서는 훨씬 빠른 stack 에 지역변수를 저장하는데 거의 사용되지 않는 클로저 구현을 위해서 이것을 포기하는 것은 비 합리적이다.
  clox 에서는 두가지 구현 전략을 사용한다. 클로저로 사용되지 않는 지역변수는 스택에 저장하고, 클로저에 의해서 캡쳐되는 지역변수는 힙으로 올린다.

## 25.1 Closure Objects
- 현재 VM 은 런타임에서 ObjFunction 을 통해서 함수를 표현한다. 이 객체는 컴파일 타임에 생성된다. VM 은 상수 테이블에서 그것을 읽어와서 이름과 바인드한다. 함수를 생성하는 오퍼레이션은 없다.
  - a function declaration in Lox is a kind of literal—a piece of syntax that defines a constant value of a built-in type.
- 아래 코드에서 makeClosure 함수는 런타임에 closure 함수를 만든다. 각각의 클로저 함수가 제대로 동작하려면 지역변수를 캡쳐하는 클로저를 위한 런타임 표현이 필요한다. 즉 기존의 표현으로는 불충분한다. 
```
fun makeClosure(value) {
  fun closure() {
    print value;
  }
  return closure;
}

var doughnut = makeClosure("doughnut");
var bagel = makeClosure("bagel");
doughnut();
bagel();
```
- 새로운 표현은 ObjClosure다. 런타임에서 함수 선언이 실행될 때, ObjFunction 를 ObjClosure 로 감싼다. ObjClosure 는 함수 그 자체와 함께 클로즈 오버되는 변수의 런타임 상태를 가진다.
### 25.1.1 Compiling to closure objects
- OP_CLOSURE 를 어떻게 emit 하는 컴파일 과정에 대해 알아보자. OP_CLOSURE 는 언제 vm 이 ObjFunction 을 감싸는 ObjClosure 를 언제 만들어야 하는지 말해준다.
### 25.1.2 Interpreting function declarations
- OP_CLOSURE 를 인터프리팅 할때, constant 에 존재하는 ObjFunction 을 읽어서, ObjClosure 로 감싼후 이것을 stack 에 올린다. ObjFunction 은 이제 constant 테이블들에만 존재하고,
  호출에 있어서도, vm 은 이제 ObjFunction 을 직접 호출하지 않고 ObjClosure 로 랩핑된 것을 호출 한다. 
- 컴파일러는 이제 매 함수 선언마다 VM 에게 클로저를 만들라고 말하는 코드를 생성한다. (the compiler now generates code telling the VM to create a closure for each function declaration.)
  
## 25.2 Upvalues
- closed-over 된 지역변수가 항상 stack 에 존재 한다면, 함수의 윈도우 이전의 스택 슬롯에 접근할 수 있도록 하면 되겠지만, 함수가 정의되는 곳 밖의 지역변수를 closed-over 하는 경우도 있다.
  이 지역변수는 stack 에 없을 수도 있다.
  또 다른 방법은 지역변수를 선언할 때 힙에 둘수 있지만 clox 는 싱글패스 컴파일러로 이렇게 할 수 없다. 아래 코드처럼 변수가 변경되는 것을 감지할 수 없기 때문이다.
  (클로즈 오버된 x 는 2 여야 한다.)
```
fun outer() {
  var x = 1;    // (1)
  x = 2;        // (2)
  fun inner() { // (3)
    print x;
  }
  inner();
}
```
- 따리서 clox 에서는 upvalue 라는 간접참조 수준을 사용한다. upvalue 는 함수의 현재 스코프에는 없지만 직접 둘러싼 함수에서 클로즈드 오버된 지역변수다. (upvalue 는 중계됨으로 더 outer 스코프의 지역변수도 참조할 수 있게 된다.)
  모든 클로저는, 각 클로저가 사용하는 주변 지역 변수에 대해서 upvalues 배열을 관리한다.
  함수 선언이 처음 실행되어서 closure 를 만들때, vm 은 upvalues 의 배열을 만들고 클로저가 필요로 하는 주변 지역변수를 캡쳐하도록 그것을 연결한다.
### 25.2.1 Compiling upvalues
- Lox 는 지역변수는 렉시컬한 스코프를 가짐으로 컴파일 타임에 클로저가 얼마나 많은 업벨류를 필요로 하는지, 어떤 것들을 캡쳐하는지 어떤 스택 슬롯이 이 변수들을 포함하는지 알 수 있다.
- 현재 컴파일러는 identifier 를 리졸브 할때, 현재 스코프에 없으면 글로벌 스코프를 찾는다. 그것을 감싸는 함수의 로컬 스코프를 고려하도록 컴파일러를 수정해야 한다.
- 컴파일러는 identifier 를 리졸브 할 때, 감싸는 함수의 지역변수의 upvalue index 를 찾아서 OP_GET_UPVALUE, OP_SET_UPVALUE 과 함께 chunk 에 기록한다.
 - Compiler.locals 와 CallFrame.slots 의 인덱스는 연동된다.
 - Compiler.upvalues 와 ObjClosure.upvalues 는 연동된다. (나중에 구현) 
※ upvalueCount 는 Function, upvalues 배열 자체는 Compiler 에 보존한다. upvalueCount 는 vm 에서 다시 사용하나? → 맞다.  

### 25.2.2 Flattening upvalues
- 아래 클로저가 제대로 동작하려면, stack 에서 이미 팝된 closed over 된 변수를 찾을 수 있어야 하고(outer()호출 후 stack 에서 이 함수 스코프의 지역변수는 모두 pop 되기 때문에), 
  바로 위의 감싸는 함수보다 위에서 정의된 지역변수를 리졸브 할 수 있어야 한다.
```
return from outer
create inner closure
value

```
```
fun outer() {
  var x = "value";
  fun middle() {
    fun inner() {
      print x;
    }

    print "create inner closure";
    return inner;
  }

  print "return from outer";
  return middle;
}

var mid = outer();
var in = mid();
in();
```
- 애초에 upvalues 는 스택을 벗어난 변수를 추적하도록 디자인 되어있다. 이 문제를 해결하는 방법은 각 함수가 다음 함수가 가저갈 수 있도록 위에서 선언된 변수를 캡쳐해서 전달 하는 것이다. 
  이렇게 하면 중첩된 함수가 실행되며 클로즈드 오버된 변수에 엑세스할때, 자신을 감싸고 있는 함수의 ObjClosure 에서 upvalue 를 통해서 그보다 위의 함수에서 선언된 지역변수를 사용할 수 있게 된다.
  이렇게 하려면 `resolveUpvalue` 를 재귀적으로 만들어야 한다.
  - Most recursive functions either do all their work before the recursive call (pre-order traversal)
  - or they do all the work after the recursive call (post-order traversal)
![linked-upvalues](linked-upvalues.png)
- resolveUpvalue 이 재귀적으로 캡쳐한 변수를 찾을때 isLocal 를 기록한다. isLocal 이 true 인 경우는 바로 위의 함수 스코프에서 지역변수를 찾았을 때다. 이는 OP_CLOSURE 를 에밋 할때,
  argument 로 같이 제공되어서 vm 에게 어디서 캡쳐된 변수를 찾아야 하는지 정보를 제공한다.
- 이제 컴파일러는 매 함수 정의마다 OP_CLOSURE 와 런타임에 캡쳐해야 하는 upvalue 를 위한 인수를 emit 한다.

## 25.3 Upvalue Objects
- upvalue 는 스택에 더 이상 살지 않는 클로즈드 오버된 변수를 관리해야 한다. 이는 어느정도 동적할당을 필요로 한다는 것이고, 이것을 가장 쉽게 하는 방법은 이미 만들어놓은 객체 시스템을 이용하는 것이다.
  location 는 값 자체가 아니라 변수에 대한 포인터 이다. 
```
typedef struct ObjUpvalue {
  Obj obj;
  Value* location;
} ObjUpvalue;
```
### 25.3.1 Upvalues in closures
- compile 타임 → Compiler.upvalues (Upvalue), run 타임 → ObjClosure.upvalues (ObjUpvalue**)  
```
typedef struct {
  Obj obj;
  ObjFunction* function;
  ObjUpvalue** upvalues; // 동적 배열에 대한 포인  
  int upvalueCount;
} ObjClosure;
```
```
case OP_CLOSURE: {
  ObjFunction* function = AS_FUNCTION(READ_CONSTANT());
  ObjClosure* closure = newClosure(function);
  push(OBJ_VAL(closure));
  for (int i = 0; i < closure->upvalueCount; i++) {
    uint8_t isLocal = READ_BYTE();
    uint8_t index = READ_BYTE();
    if (isLocal) {
      closure->upvalues[i] = captureUpvalue(frame->slots + index); // isLocal 인경우 감싸는 함수의 stack 의 위치로 ObjUpvalue 를 만든다.
    } else {
      closure->upvalues[i] = frame->closure->upvalues[index]; // 모든 실행은 콜프래임 안에서 이루어지고 상위 closure의 upvalue 에서 값을 찾아오는건 타당하다.
    }
  }
  break;
}
```
- OP_CLOSURE 를 처리하면서, compile 타임에 캡쳐된 upvalue 를 CallFrame.ObjClosure.ObjUpvalue 로 옮긴다. 
  이후 OP_GET_UPVALUE 는 CallFrame.ObjClosure.ObjUpvalue 에서 upvalue 를 찾아 stack 에 올린다.
- compiler 에서 변수를 컴파일한 결과가 (OP_GET_LOCAL, OP_SET_LOCAL), (OP_SET_UPVALUE, OP_GET_UPVALUE), (OP_GET_GLOBAL, OP_SET_GLOBAL) 이 된다. 
  - resolve 는 compile 타임에 이루어진다. compiler 는 변수 이름을 local 에 저장하고 있다가, resolve 한뒤 OP_GET_LOCAL 과 slot 인덱스를 돌려준다.
    upvalue 의 경우도 resolve 는 컴파일 타임에 resolveUpvalue 를 통해 이루어진다. 
    
## 25.4 Closed Upvalues
- Upvalue 는 stack 의 지역변수의 위치를 저장하기 때문에 스코프가 종료되엇 stack 이 리셋되면 클로즈드 오버된 변수에 접근할 방법이 없다.
  이를 위해서 값 자체를 저장해야 한다.
```
fun outer() {
  var x = "outside";
  fun inner() {
    print x;
  }

  return inner;
}

var closure = outer();
closure();
```
### 25.4.1 Values and variables
- Lox 를 포함한 거의 모든 언어의 클로저는 값이 아니 변수를 캡쳐한다. 값이 살고 있는 장소를 캡쳐하는거라고 생각할 수 있다.
### 25.4.2 Closing upvalues
- stack 에 여전히 남이있는 지역변수를 가르키는 upvalue 를 "open upvalue" 라고 부르고, 힙으로 이동된(ObjUpvalue 자체에 저장된) upvalue 를 closed upvalue 라고 부른다. 클로저의 구현에 있어서 다음과 같은 두가지 질문에 답해야 한다.
  - 닫힌 업벨류의 지역변수는 힙의 어디에 저장되어야 하는가? → 이미 구현한 객체 시스템의 ObjUpvalue 의 필드를 정의해 그곳에 저장한다.  
  - 언제 upvalue 를 닫아야 하는가? → 로컬 변수를 벗어나는 시점. 현재의 컴파일러는 지역변수가 캡쳐되었다는 걸 알 수 없음으로, Local 에 isCaptured 플래그를 추가하고 OP_CLOSE_UPVALUE 를 에밋한다.  
### 25.4.3 Tracking open upvalues
- 다른 클로저가 캡쳐된 변수를 변경하더라도 그 변수가 공유되도록 해야한다. 이를 위해서 먼저 VM 이 모든 open upvalue 들의 리스트를 관리하도록 해야 한다.
### 25.4.4 Closing upvalue at runtime
- 컴파일러에서 클로즈드 오버된 지역변수를 발견하면 isCaptured 를 마킹해 둔다. scope 를 닫을 때 isCaptured 마킹이 된 지역변수를 발견하면, OP_CLOSE_UPVALUE 를 emit 한다.  
  vm 에서는 OP_CLOSE_UPVALUE 를 인터프리팅 할때, ObjUpvalue 의 location 포인터를 디레퍼런싱해서 closed 필드에 값을 저장한 다음, location 이 다시 그 필드를 가르키게 한다.
  vm 은 openUpvalues 를 필드로 가지고 있음으로 함수가 리턴할 때, closeUpvalues 를 호출해서 upvalue 들에 대해서 closed 처리를 한다.
- JLox 에서는 모든 환경을 heap 두는 것으로 복잡도는 감소했지만 성능이 좋지 못했다. CLox 에서는 더 복잡하지만, stack 시멘틱을 가지는 local 변수와 (빠른), 클로즈드 오버 되는 변수 두가지 패턴에 적합한 구현으로 성능이 향상되었다.  
  최적화의 만은 부분은 특정한 사용의 코드를 찾아내고 그 코드를 위한 빠른 길을 제공하는 것이다.

## Challenges
- 1. 모든 ObjFunction 을 ObjClosure 로 래핑하는것은 간접참조 수준을 만들고 그것은 성능상의 비용이 있다. upvalue 가 필요한 함수만 ObjClosures 로 래핑하도록 하라.
   그리고 항상 랩핑하는것에 비해서 코드의 복잡도와 성능은 어떤지 비교하라.
  - 함수가 캐싱될까? 성능상의 이점은 적고 구현의 복잡도만 증가할 것 같다.
- 2. lox 의 iteration 에서 각각의 반복에서 변수가 생성되도록 구현을 변경하라.
  - 많은 언어의 스펙을 따르는게 좋아 보인다. 
- 3. "객체는 가난한자의 클로저", "클로저는 가난한자의 객체" 라는 유명한 화두가 있다. 클로저를 사용해서 x, y 를 필드로 가지는 vector 객체를 정의하라 

## Design Note: Closing over the loop variable
- 언어가 higher-level iterator-based looping structure 를 가지고 있다면, 이 구조 안에서 매 루프마다 새로운 변수가 정의되는 것으로 보는게 자연스럽다.
  사용자가 기대하는 대로 동작하게 하는게 좋다. (c# 에서는 foreach 에 대해서 이례적으로 새로운 변수를 만들도록 큰 변경을 했다.)
