# Strings 요약



# 문단별 흥미로운 내용
## 19.1 Values and Objects
- 우리가 변수에 저장하거나, 표현식에서 계산된 값은 Value 가 된다. 작은 크기가 정해진 타입의(숫자,불리언) 페이로드는 Value 구조체 안에 직접 저장된다.  
  오브젝트가 크다면 그것은 힙에 존재하고 Value 의 페이로드는 메모리상의 바이너리 오브젝트에 대한 포인터(Obj)*가 된다.
## 19.2 Struct Inheritance
- 오브젝트들은 각각 다른 필드를 갖는다. 모든 형태의 오브젝트와 일하는 코드는 다형적으로 Obj 로만 오브젝트들을 다루어져야 할 필요가 있다. 
  C 의 구조체는 첫번째 필드부터 정렬이 되도록 되어있어서 ObjString* 을 Obj* 로 캐스트한 뒤 엑세스 할 수 있다.
  → ![obj](obj.png) 
## 19.3 Strings
- compiler 에서는 string 함수를 사용해서 Obj 를 가지고 있는 Value 를 chunk 에 emit 한다.
- source 코드의 lexeme 에 대한 포인터를 가지지 않고, 힙에 복사해서 자유롭게 사용하고 '해제' 한다.
- allocateString 를 ObjString* 의 constructor 처럼 활용한다. allocateObject 를 Obj* 의 constructor 처럼 활용한다.
  - allocateObject 호출은 allocateString 로 돌아오고 ObjString* 생성을 완료한다.
## 19.4 Operations on Strings
- copyString 은 호출자가 오너십을 가지고 있다고 생각하지 않고, 보수적으로 사본을 만든다, takeString 은 호출자가 오너십을 가지고 있다고 생각하고 인수로 받은걸 가지고 그대로 ObjString* 를 생성한다.
## 19.5 Freeing Objects
- `"st" + "ri" + "ng"` 를 실행 했을 때, 각각의 상수는 chunk 에 존재한다. 중간 연산인 "stri" 이 만들어지고 최종적으로 "string" 이 stack 에 들어가지만, 중간 연산은 그대로 메모리에 남아있다. 전형적인 메모리 누수 문제다.  
　→　garbage collector 로 이 문제를 해결하지만, 사전작업이 필요하다.
The longer we wait to add the collector, the harder it is to do... 계속

