# Handling Overload


metric 측정기준
overload 과부하
overhead 간접비



## The Pitfalls of Queries per Second
Queries per Second 리퀘스트마다 사용하는 리소스 양이 다르기 때문에 이 메트릭은 정확하지 못하다.
대신에 백엔드의 실시간 cpu 사용시간을 메트릭으로 활용하는데 잘 동작한다.
## Per Customer Limits
실시간으로 cpu 사용시간을 측정해서 Customer Limit 을 설정한다. limit 을 넘으면, 에러를 리턴한다.
## Client-Side Throttling
어떤 요청들은 실제로 요청을 처리하는것과 에러를 되돌려주는것의 비용차이가 거의 없기도 하다.
이런경우 백엔드는 에러를 돌려주다가 오버로드상태가 됨으로 클라이언트 측에서의 Throttling 이 필요하다.
requests 와 accepts 를 2분동안 측정해서 임계를 넘으면 클라이언트 측에서 요청을 실패처리할 수 있다.
이 방법을 adaptive throttling 라고 한다.
로컬 정보에 기반해서 결정을 내리기때문에 추가적인 종속성이나 통신 오버헤드가 없다.
단 클라이언트측에서 백엔드에 빈번하게 요청을하지 않는 경우라면 이 메카니즘은 비효율적일 수 있다.
(백엔드 상태가 변하더라도 클라이언트로의 정보 반영에 큰 타임러그가 발생함으로..)

## Criticality
리퀘스트의 중요도를 네가지로 나누고 전체 시스템에서 도입했다. RPC 에서 중요도는 자동으로 전파된다.
리퀘스트의 중요도와 지연시간 요구사항은 직교하며 예를들어 검색 결과를 제안해주는 요청의 경우 중요도는 낮지만(오버로드 될때 무시될 수도 있지만) 요구되는 지연시간은 매우 짧을 수 있다.

## Utilization Signals 활용 시그널
하드웨어 리소스의 Utilization 수치로 thresholds 를 설정하고 그것을 넘었을때 리퀘스트를 거부하도록 할 수 있다. (우선순위가 높으면 thresholds도 높다.)
평균 값을 사용하기 때문에 큰 fan out 을 가진 리퀘스트에 의해서 일시적으로 Utilization 수치가 높아지는 경우에도 지속되지않으면 평균에 흡수됨으로 리퀘스트를 거부하지 않는다.

## Handling Overload Errors
많은 백엔드 서브셋이 과부하 되는경우랑, 적은 벡엔드 서브셋이 과부하되는 경우가 다른다.
많은 서브셋이 과부하 되는경우 에러를 엔드유저에게 돌려줘야한다. 후자의 경우가 더욱 빈번하고 이 경우 단순히 처리 재시도를 한다.
첫번재 요청과 재시도 요청을 명시적으로 구분하지 않고 재시도 요청이 처리되도록 보장하지 않고 높은 확률로 처리되도록 한다.
백엔드가 아주조금 과부하 되는경우여도 요청이 거부되고 재시도에 의해서 리소스에 여유가 있는 테스크가 이를 처리하도록 하면 부하분산이 유기적으로 이루어진다.

### Deciding to Retry
클라이언트는 작업 과부하 응담을 받으면 재시도할지를 결정해야 한다.
이미 과부하가된 상태에서 재시도를 피하기 위해서, 요청당 최대 3회의 재시도를 제한하고, 클라이언트별로 최대 재시도 요청의 비율을 10%로 제한 하는 것 이다.
10% 비율을 설정하지 않으면 최악의 경우 각각의 요청에 대해서 재시도가 x3 이 된다. 거부하는데도 리소스를 소비함으로 이는 문제가 될수 있다.
10% 비율의 캡을 설정하면 이런한 문제없이 10%에 도달했을 때 재시도 없이 요청이 실패한다. (요청을 거부하는데 드는 리소스사용을 제한 할 수 있다.)
서비스는 스택이 깊이 쌓여있는 경우가 있고, 재시도 요청의 조합이 폭팔하지 않도록 재시도는 바로 위의 레이어에서만 이루어져야하고 위의 레이어에 재시도 요청을 하지 말라는 메세지를 전달해야한다.
그렇지 않으면 예를들어 스택이 2단인 경우, 가장 아레 스택에서 3번의 재시도 실패로 상위 레이어로 에러가 버블업 되고 다시 상위 레이어에서 3번의 재시도를 하게 됨으로 총 9번의 재시도가 발생할 수 있다.

## Load from Connections
스케일이 커지면 커넥션이 문제가 되고, 비활성 커넥션 메카니즘을 사용할 수 있지만 요청이 빈번하지 않은 서비스의 경우는 이러한 방법이 비효율적이다.
새로운 커넥션 생성이 폭팔을 다루기위해서 로드벨런싱이 데이터 센터의 부하를 확인하고 부하가 적은 쪽으로 요청을 보내게 하거나 배치 클라이언트가
직접 백엔드에 요청을 보내지않고 batch proxy(다시 로드밸런싱을 수행하는) 를 거치게 하는 방법이 있다.

## Conclusions
백엔드에서는 subsetting, weighted Round Robin, client-side throttling, customer quotas 등 로드밸런싱을 위해 다향항 테크닉을 사용한다.
과부하의 처리에 있어서, 개별작업은 과부하로부터 보호되어야 한다.  응답이 느려지거나 실패하는것이 아니라, 정해진 양의 트래픽에 대해서는 과부하가 아닐때와 똑같이 처리할 수 있어야한다.
로드밸런싱에 의해서 백엔드는 가능한 많은 트래픽을 받아들이고 그들이 처리할 수 있을 만큼의 요청만 수락하고 그 이상은 적절히 거절해야한다.
