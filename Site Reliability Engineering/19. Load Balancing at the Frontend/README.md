
# Load Balancing at the Frontend
데이터 센터간 로드벨런싱과, 데이터 센터 내에서의 로드벨런싱의 구현에 대해 다룬다.  

## Power isn't The Answer
강력한 한개의 머신이 있더라도, 네트워크 인프라의 물리적 제약 조건때문에 또 단일 실패지점을 만들고 싶지 않기 때문에 그것을 사용하지 않을 것이다.
구글에서는 수많은 머신을 사용하고, 수많은 네트워크 링크, 데이터 센터, 그리고 머신으로 트래픽이 최적의 방식으로 분산된다.
최적의 방식에는 다음과 같은 것들이 고려된다.
- 문제를 평가하고자하는 계층의 수준
- 문제를 평가하고자하는 기술적 수준
- 다루려고 하는 트래픽의 특성
예를들어서 검색 요청과 동영상 업로드 요청을 보면, 검색요청은 무조건 빨라야한다. 동영상 업로드 요청은 너무 느리면 안되지만 실패없이 한번에 성공하는게 중요하다.
각각의 요청에서 글로벌 레벨에서 중요한 것은 지연과 처리량이 된다. 
하지만 로컬 레벨에서는 특정 서버에 부하가 집중을 방지하고 리소스를 최적으로 활용하는것이 중요하다.

## Load Balancing Using DNS
dns 는 로드밸렁싱을 수행할 수 있는 첫번째 레이어다. 이것을 DNS Load Balancing 이라고 한다.  
단순하게 dns 가 복수의 a 레코드를 돌려주고 클라이언트가 그것을 랜덤하게 선택하게 하는 방법을 사용할 수 있다.   
이 방법은 개념상으로는 간단하지만 이 솔루션은 몇가지 도전을 쥐고 있다.  

첫번째 문제는 클라이언트를 제어할 수 없고, 무작위로 레코드를 선택함으로 비슷한 향의 트래픽을 끌어들이게 된다는 것이다.  
SRV 레코드가 있기는 하지만 http 표준은 아니다.  
			
두번째 문제는 클라이언트가 잠재적으로 가장 가까운 주소를 확인할 수 없다는 것이다.   
권한이 있는 네임서버가 다시 가장 가까운 주소를 할당하는 방법이 있지만 이 솔루션은 복잡한 dns 서버 구현과 위치매핑을 최신상태로 유지해야한다는 대가가 따른다.  

최종사용자가 권한이 있는 네임서버와 직접 통신하지 않는다는 사실 때문에 위의 어느 솔루션도 쉽게 구현 할 수 없다.  
DNS 에는 미들맨이 있고, 재귀적 ip 해결이 사용된 경우 최종사용자의 위치를 알 수 없어서 가장 가까운 데이터센터를 연결할 수 없고, 또 캐슁 문제도 있다.  
표준은 아니지만 요청에 최종 사용자의 ip 정보를 포함하도록 대형 DNS 가 이미 지원하고 있다.  

거리말고도 서버가 충분한 용량을 하지고있는지 네트워킹 문제가 없는지도 확인해야한다.  
권위있는 dns와 구글의 글로벌 시스템(용량과 상태를 컨트롤하는)을 통합해서 위와 같은 이슈도 로드밸런싱에서 다룰 수 있게했다.  
DNS 미들맨에 대해서는 할수있는게 없다.


## Load Balancing at the Virtual IP Address
VIP 는 IP 처럼 실제로 어떤 머신과 1:1로 연결되는건 아니지만 사용자 입장에서는 같다.  
VIP 구현의 가장 중요한 부분은 network load balancer 이다.  
VIP 뒤에 여러개의 백엔드를 둔 후에, 수신하는 패킷을 가장 부하가 적은 서버로 연결할 수 있다.  
프로토콜이 stateful 한 프로토콜인 경우 같은 backend 를 연결해줘야 하기때문에 위의 단순한 알고리즘은 사용할 수 없다.  

network load balancer 가 모든 커넥션을 추적하면서 패킷을 올바른 백엔드로 보내는 방법도 있지만,  
id(packet) mod N(서버 수) 으로 연결ID 를 생성하고, 상태관리 없이 올바른 백엔드로 패킷을 전송할 수 있다.  
이 방법을 사용하면 상태를 저장할 필요가 없다. 하지만 만약 서버가 추가되거나 감소한다면 모든 커넥션이 다시 설정되어야한다.  
서버수가 추가되거나 감소되어도 기존 해쉬값이 변하지 않도록 하는 consistent hashing 을 사용하면 이러한 문제를 해결할 수 있다.   

network load balancer 가 패킷이 어떻게 정확한 백엔드로 전송되게 할 수 있을까?  
한가지 방법은 Network Address Translation 을 사용하는 것이다. 이를 위해서는 커넥션테이블을 추적해야한다.  
다른 방법은 layer2 의 mac 주소를 수정해서 dst 로 설정하는 것이다. network load balancer 에 수신된 모든 정보는 서버로 전달되고  
이렇게 한번 연결이 되고 나서 백엔드 서버는 클라이언트와 직접 통신한다.   
이를 Direct Server Response 라고 한다.   
로드밸런싱이 적은 패킷만 사용되기 때문에 이 해결책은 대체로 유효하지만 백엔드 서버들이 single broadcast domain 를 공유해야 함으로 규모가 큰경우 적합하지 않다.  
		
구글은 Generic Routing Encapsulation (GRE) 를 사용한다. 추가적인 패킷 오버헤드를 사용해서 백엔드 서버로 라우팅하고,  
백엔드 서버는 오버헤드를 제거한 다음, 나머지 정보로 클라이언트와 직접 통신한다. 이렇게 하면 LB 와 백엔드 서버가 다른 대륙에 있더라도 LB에 의해 서버가 지정될 수 있다.  
단점은 오버헤드가 발생한다는 것이고, 이 오버헤드 때문에 패킷이 사용 가능한 최대 전송 단위를 초과해서 패킷의 조각화가 필요할 수도 있다는 것이다.   
대규모 부하 분산은 조기에 부하를 분산하고, 자주 부하를 분산한다는 점에서 표면적으로는 간단해보이지만 세부적인 부분에서 어려움이 있다.   
