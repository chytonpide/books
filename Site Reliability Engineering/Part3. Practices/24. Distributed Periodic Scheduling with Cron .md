# Distributed Periodic Scheduling with Cron
분산 크론 서비스가 마주하는 문제들과 해결방법에 대해서 살펴본다.
먼저 크론의 기본원리를 살펴본 다음, 시스템의 안정성을 높이기 위해서 크론이 대규모 분산환경에서 어떻게 동작할 수 있는지 검토한다.
분산 크롬 시스템을 몇몇의 머신으로 배포되지만 데이터센터의 스케쥴링 시스템과 결합해서 전체 데이터 센터에 걸쳐서 크론 job 을 실행 시킬 수 있는 것으로 묘사한다.       


## Cron
crontab 이라는 포멧을 사용하고 crond 가 job의 list 를 읽어서 실행한다.
reliability 측면에서 cron 은 한 머신에서만 동작해서 단일 실패지점이 될 수 있고, fire-and-forget 방식이라 실행을 추적하지 않는다.
anacron 라는 하루 단위로 작업을 추적하는 서비스도 있다. (실행의 timestamp를 기록한다.)


## Cron Jobs and Idempotency
job의 종류에는 Idempotency 한 것도있고 아닌 것도 있다.
구글은 job이 두 번 실행 되느니 그냥 실패하고 끝나는 걸 선호한다.
실행을 건너뛴 상태에서 부터 복구하는 것은 일반적으로 두번 실행된 상태에서 복구하는 것 보다 복구가 용이하다.


## Cron at Large Scale
소규모 배포와 대규모 배포의 차이점을 논의하고 대규모 배포에서 어떤 것들이 필요한지 묘사한다.

### Extended Infrastructure
대규모 시스템에서는 크론 솔루션은 목수의 머신으로 배포된다.
하나의 머신에 크론을 두는건 단일 실패지점이 됨으로 안정성 측면에서 좋지 않다.
프로세스와 머신을 분리해서 데이터센터 스케쥴러에게 job 의 실행 요청을 보내도록 한다.
이러한 프로세스들은 기본적으로 즉시 실행이 불가하다, 스케줄링으로 인한 시간 오버헤드가 발생하고, 머신 중간에 교체되어서 일부 상태가 유실될 수도 있다.
로컬 상태 분실과 시간 요구상항 초과 문제를 경감하기 위해서 GFS(google file system) 같은 분산 파일 시스템이나 hot spares(빨리 다른 머신에서 오퍼에리션을 재개할 수 있는) 를 사용하는것이 해결책이 될 수 있다.

### Extended Requirements
하나의 머신에서 각 프로세스는 고립되어있지 않다. crond 와 cron job도 마찬가지로 고립되어있지 않다.
데이터센터 규모에서는 각각의 프로세스는 격리되어있다.
프로세스를(crond 와 cron job도) 실행하기 위해서 필요한 리소스의 양을 알아야 하고, 이것은 우리가 크론잡의 실행부터 종료까지의 상태를 추적해야 함을 의미한다.
특정 머신과 프로세스 실행을 분리하면 크론 시스템은 부분적인 실패에 노출될수 있다
예를들어 어떤 cron job 이 복수의 RPC가 필요할때, 일부만 성공할 수 있다. 크론의 복구절차는 이러한 시나리오도 고려해야한다.
데이터센터에서 부분적인 장애가 발생해도 크론 서비스가 계속해서 작동할 수 있게 하기 위해서 크론 서비스의 사본을 여러곳에 위치시킨다.


## Building Cron at Google

### Tracking the State of Cron Jobs
실행 종료 상태를 추적해야 하는건 중요한 요구사항이다.
크론 서비스가 자체적으로 상태를 관리하도록 설계했다.
- 작은 용량의 상태관리에 GFS 등 대용량 처리에 적합한 시스템을 사용하는건 비효율적이다.
- 중단이 광범위한 영향을 미치는 크론서비스는 다른 시스템에 종속적이지 않도록 하는게 더 좋다.

### The Use of Paxos
Cron 서비스의 복제본을 배포한 다음 복제본들 사이에서 리더를 선출하고 일관된 상태를 유지하는데 Paxos 알고리즘을 사용한다.
Paxos 에서 보관하는 가장 중요한 상태는 job의 실행과 종료이다.
Fast Paxos 알고리즘을 사용하여 리더가 교체될 때 1분 이내로 교체된다.
_※failover: 장애복구_

### The Roles of the Leader and the Follower
#### The leader
job을 실행하는 유일한 복제본이다. job의 실행과 종료를 Paxos와 동기 통신을 해서 알린다.
Paxos 는 이러한 상태를 follower 복제본에게 알린다.
리더는 리더십을 잃는 즉시 데이터센터 스케쥴러와의 상호작용을 중단해야 한다.
#### The follower
Paxos 를 통해서 job 의 실행상태를 공유받는다. 복제본 간에도 상태의 일관성이 유지되어야 한다.
실행간격이 짧은 job도 있음으로 리더가 교체 될 때 1분 이내로 빠르게 교체 되어야 한다.

### Resolving partial failures
논리적인 하나의 job이 몇몇 RPC 를 수반하는 경우가 있다. 시스템은 여러 RPC를 수행하는 도중에 실패하는 상황을 다룰 수 있어야 한다.
어떤 job의 종료를 보고받기 전에 리더가 교체된다면 RPC가 실제로 전송되었는지 확인하려면 다음 조건중 하나가 충족되어야 한다.
- 외부 시스템에 대한 오퍼레이션이 멱등해야 한다. (재선출 후 그냥 job을 다시 실행할 수 있다.)
- 외부 시스템에 대한 모든 오퍼레이션에 대한 상태를 조회할 수 있어야 한다.
데이터센터 스케줄러에서 실행되는 job에 이름과 실행시간으로 job을 식별할 수 있게 하면,
새 리더가 선출되었을 때 데이터 스케줄러에서 실행되는 job을 식별해서 중복실행을 방지할 수 있다.

### Storing the State
단기적인 상태는 cron 서비스내에 저장하고 snap shot을 분산 스토리지에 저장했다.
단기상태는 모든 리플레카가 가지고있고 새로운 리플래카를 시작할 때 자동으로 이 상태가 동기화 되도록 해서 재시작이나 리플래카 교체가 이슈가 되지 않도록 했다.

### Running Large Cron
같은 시간에 작업이 몰리는 것을 방지하기 위해 크론탭의 포맷을 확장해서 `?`를 도입했다.
_※thundering herd: 폭팔적인 몰림 현상?_


## Summary
cron 은 유닉스 시스템에서 널리 사용된 기능이다.
분산시스템으로 트랜드가 이동하면서 데이터 센터가 가장 작은 효과적인 하드웨어 단위가 되었고 스택에 많은 변경을 요구하게 되었다.
cron 도 이러한 변화에 발 맞춰야 했다.

분산 시스템 환경에서 요구되는 새로운 제약조건과 가능한 설계를 알아봤다.
해결책은 분산환경에서 강력한 일관성 보증을 요구 했기 때문에 분산 크론의 구현 코어는 paxos 가 되었다.
paxos 의 사용과 대규모 크론 job의 장애 형태를 정확히 분석함으로써 탄탄한 서비스를 제공할 수 있게 되었다. 

 